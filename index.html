<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>InfiniteFlight</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{overflow:hidden;background:#000;font-family:'Courier New',monospace}
canvas#main{display:block;width:100vw;height:100vh}
#hud{position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:10}
#hud *{pointer-events:auto}
.hud-text{color:#00ff88;font-size:14px;text-shadow:0 0 8px #00ff8866,0 0 2px #00ff88}
#hud-left{position:absolute;left:20px;top:50%;transform:translateY(-50%)}
#hud-left .gauge{margin:8px 0;padding:6px 10px;background:rgba(0,20,10,0.6);border:1px solid #00ff8844;border-radius:4px}
#hud-left .gauge .val{font-size:28px;font-weight:bold;color:#00ff88;text-shadow:0 0 12px #00ff88aa}
#hud-left .gauge .lbl{font-size:10px;color:#00ff8899;letter-spacing:2px}
#hud-right{position:absolute;right:20px;top:20px}
#hud-right select{background:rgba(0,20,10,0.8);color:#00ff88;border:1px solid #00ff8844;padding:6px 10px;font-family:'Courier New',monospace;font-size:12px;margin:4px 0;display:block;width:180px;border-radius:4px;cursor:pointer;outline:none}
#hud-right select:hover{border-color:#00ff88}
#hud-right select option{background:#001a0d;color:#00ff88}
#throttle-container{position:absolute;left:20px;bottom:30px}
#throttle-bar{width:20px;height:120px;background:rgba(0,20,10,0.6);border:1px solid #00ff8844;border-radius:3px;position:relative}
#throttle-fill{position:absolute;bottom:0;width:100%;background:linear-gradient(to top,#00ff88,#00cc66);border-radius:2px;transition:height 0.1s}
#throttle-label{color:#00ff8899;font-size:10px;text-align:center;margin-top:4px;letter-spacing:2px}
#horizon-container{position:absolute;left:50%;bottom:30px;transform:translateX(-50%)}
#horizon-canvas{border:3px solid #00ff88aa;border-radius:50%;background:rgba(0,20,10,0.5);box-shadow:0 0 12px #00ff8844}
#instructions{position:fixed;top:0;left:0;width:100%;height:100%;display:flex;align-items:center;justify-content:center;z-index:100;background:rgba(0,0,0,0.7);transition:opacity 1s}
#instructions.hidden{opacity:0;pointer-events:none}
#instructions-box{background:rgba(0,20,10,0.9);border:1px solid #00ff8866;border-radius:12px;padding:40px;max-width:520px;color:#00ff88;text-align:center}
#instructions-box h1{font-size:28px;margin-bottom:6px;text-shadow:0 0 20px #00ff88aa}
#instructions-box h3{font-size:13px;font-weight:normal;color:#00ff8888;margin-bottom:20px}
#instructions-box table{margin:0 auto 16px;text-align:left;font-size:12px;border-collapse:collapse}
#instructions-box td{padding:3px 12px}
#instructions-box td:first-child{color:#00ffaa;font-weight:bold}
#instructions-box .start-hint{margin-top:16px;font-size:11px;color:#00ff8866;animation:pulse 2s infinite}
@keyframes pulse{0%,100%{opacity:0.5}50%{opacity:1}}
#menu{position:fixed;top:0;left:0;width:100%;height:100%;display:none;align-items:center;justify-content:center;z-index:90;background:rgba(0,0,0,0.6)}
#menu.active{display:flex}
#menu-box{background:rgba(0,20,10,0.9);border:1px solid #00ff8866;border-radius:12px;padding:30px;color:#00ff88;text-align:center}
#menu-box h2{margin-bottom:16px}
#menu-box table{margin:0 auto;font-size:12px;text-align:left;border-collapse:collapse}
#menu-box td{padding:2px 10px}
#menu-box td:first-child{color:#00ffaa;font-weight:bold}
#menu-box .close-hint{margin-top:16px;font-size:11px;color:#00ff8866}
#controls-panel{position:fixed;top:12px;left:12px;z-index:15;background:rgba(0,20,10,0.55);border:1px solid #00ff8833;border-radius:6px;padding:8px 12px;font-family:'Courier New',monospace;font-size:11px;color:#00ff8899;line-height:1.6;pointer-events:none;text-shadow:0 0 4px #00ff8844}
#controls-panel span{color:#00ffaa;font-weight:bold}
#crash-overlay{position:fixed;top:0;left:0;width:100%;height:100%;display:none;align-items:center;justify-content:center;z-index:200;background:rgba(0,0,0,0.7);flex-direction:column}
#crash-overlay.active{display:flex}
#crash-overlay h1{font-family:'Courier New',monospace;font-size:72px;color:#ff3333;text-shadow:0 0 30px #ff000088,0 0 60px #ff000044;margin-bottom:20px}
#crash-overlay p{font-family:'Courier New',monospace;font-size:18px;color:#ff8888;animation:pulse 2s infinite}
#taxi-hud{position:fixed;bottom:200px;left:50%;transform:translateX(-50%);z-index:15;display:none;background:rgba(0,20,10,0.8);border:1px solid #00ff8866;border-radius:6px;padding:8px 18px;font-family:'Courier New',monospace;font-size:13px;color:#00ff88;text-shadow:0 0 8px #00ff8866;letter-spacing:1px}
#taxi-hud.active{display:block}
#taxi-hud span{color:#00ffaa;font-weight:bold}
#godmode-indicator{position:fixed;top:12px;left:50%;transform:translateX(-50%);z-index:15;display:none;background:rgba(0,20,10,0.7);border:1px solid #ffaa00;border-radius:4px;padding:4px 14px;font-family:'Courier New',monospace;font-size:13px;color:#ffaa00;text-shadow:0 0 8px #ffaa0066;letter-spacing:2px}
#godmode-indicator.active{display:block}
#view-btn{position:fixed;bottom:20px;right:20px;z-index:15;background:rgba(0,20,10,0.7);border:1px solid #00ff8844;border-radius:6px;padding:8px 14px;font-family:'Courier New',monospace;font-size:12px;color:#00ff88;cursor:pointer;text-shadow:0 0 6px #00ff8866}
#view-btn:hover{border-color:#00ff88;background:rgba(0,40,20,0.8)}
#instrument-panel{position:fixed;bottom:8px;left:50%;transform:translateX(-50%);z-index:12;pointer-events:none}
#instrument-canvas{background:transparent}
#autopilot-indicator{position:fixed;top:40px;left:50%;transform:translateX(-50%);z-index:15;display:none;background:rgba(0,20,10,0.7);border:1px solid #00aaff;border-radius:4px;padding:4px 14px;font-family:'Courier New',monospace;font-size:13px;color:#00aaff;text-shadow:0 0 8px #00aaff66;letter-spacing:2px}
#autopilot-indicator.active{display:block}
</style>
</head>
<body>
<canvas id="main"></canvas>
<div id="hud">
  <div id="hud-left">
    <div class="gauge"><div class="val" id="speed-val">0</div><div class="lbl">KTS</div></div>
    <div class="gauge"><div class="val" id="alt-val">0</div><div class="lbl">ALT FT</div></div>
    <div class="gauge"><div class="val" id="hdg-val">000</div><div class="lbl">HDG</div></div>
  </div>
  <div id="hud-right">
    <select id="aircraft-select">
      <option value="0">Biplane</option>
      <option value="1" selected>Cessna</option>
      <option value="2">Glider</option>
      <option value="3">Paraglider</option>
      <option value="4">Hang Glider</option>
      <option value="5">F-117 Nighthawk</option>
      <option value="6">F-14 Tomcat</option>
    </select>
    <select id="location-select">
      <option value="0" selected>Tropical Islands</option>
      <option value="1">Rain Forest</option>
      <option value="2">Desert</option>
      <option value="3">Redwood Forest</option>
      <option value="4">Yosemite</option>
      <option value="5">SF Bay</option>
      <option value="6">Chicago</option>
      <option value="7">Bellagio / Lake Como</option>
    </select>
  </div>
  <div id="throttle-container">
    <div id="throttle-bar"><div id="throttle-fill" style="height:30%"></div></div>
    <div id="throttle-label" class="hud-text">THR</div>
  </div>
  <div id="horizon-container">
    <canvas id="horizon-canvas" width="180" height="180"></canvas>
  </div>
  <div id="instrument-panel">
    <canvas id="instrument-canvas" width="660" height="160"></canvas>
  </div>
</div>
<div id="instructions">
  <div id="instructions-box">
    <h1>InfiniteFlight</h1>
    <h3>Browser-Based 3D Flight Visualization</h3>
    <table>
      <tr><td>↑ / ↓</td><td>Pitch</td></tr>
      <tr><td>← / →</td><td>Roll</td></tr>
      <tr><td>W / Shift</td><td>Throttle Up</td></tr>
      <tr><td>S / Ctrl</td><td>Throttle Down</td></tr>
      <tr><td>Space</td><td>Brake (ground)</td></tr>
      <tr><td>V</td><td>Toggle View</td></tr>
      <tr><td>G</td><td>God Mode</td></tr>
      <tr><td>R</td><td>Reset</td></tr>
      <tr><td>A</td><td>AutoPilot Tour</td></tr>
      <tr><td>1-7</td><td>Switch Aircraft</td></tr>
      <tr><td>Mouse</td><td>Look Around (click first)</td></tr>
      <tr><td>ESC</td><td>Menu / Release Mouse</td></tr>
    </table>
    <div class="start-hint">Click anywhere to begin</div>
  </div>
</div>
<div id="menu">
  <div id="menu-box">
    <h2>InfiniteFlight</h2>
    <table>
      <tr><td>↑ / ↓</td><td>Pitch</td></tr>
      <tr><td>← / →</td><td>Roll</td></tr>
      <tr><td>W / Shift</td><td>Throttle Up</td></tr>
      <tr><td>S / Ctrl</td><td>Throttle Down</td></tr>
      <tr><td>Space</td><td>Brake (ground)</td></tr>
      <tr><td>V</td><td>Toggle View</td></tr>
      <tr><td>G</td><td>God Mode</td></tr>
      <tr><td>R</td><td>Reset</td></tr>
      <tr><td>A</td><td>AutoPilot Tour</td></tr>
      <tr><td>1-7</td><td>Switch Aircraft</td></tr>
      <tr><td>Mouse</td><td>Look Around</td></tr>
    </table>
    <div class="close-hint">Press ESC to close</div>
  </div>
</div>
<div id="controls-panel">
  <span>↑↓</span> Pitch &nbsp;<span>←→</span> Roll<br>
  <span>W/⇧</span> Thr+ &nbsp;<span>S/Ctrl</span> Thr-<br>
  <span>Space</span> Brake &nbsp;<span>V</span> View<br>
  <span>G</span> God Mode &nbsp;<span>R</span> Reset<br>
  <span>A</span> AutoPilot &nbsp;<span>1-7</span> Aircraft
</div>
<div id="crash-overlay">
  <h1>CRASHED</h1>
  <p>Press R to restart</p>
</div>
<div id="taxi-hud">GROUND  <span>←→</span> Steer  <span>Space</span> Brake  <span>W/⇧</span> Throttle</div>
<div id="godmode-indicator">GOD MODE</div>
<div id="autopilot-indicator">AUTOPILOT</div>
<button id="view-btn">V: Cockpit</button>
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
  }
}
</script>
<script type="module">
import * as THREE from 'three';
import { Water } from 'three/addons/objects/Water.js';
import { Sky } from 'three/addons/objects/Sky.js';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
import { FXAAShader } from 'three/addons/shaders/FXAAShader.js';
import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

// ─── NoiseGenerator ───
class NoiseGenerator {
  constructor(seed = 0) {
    this.grad3 = [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],[1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],[0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]];
    this.p = new Uint8Array(512);
    const src = new Uint8Array(256);
    for (let i = 0; i < 256; i++) src[i] = i;
    let s = seed || 1;
    for (let i = 255; i > 0; i--) {
      s = (s * 16807 + 0) % 2147483647;
      const j = s % (i + 1);
      [src[i], src[j]] = [src[j], src[i]];
    }
    for (let i = 0; i < 512; i++) this.p[i] = src[i & 255];
  }
  dot2(g, x, y) { return g[0]*x + g[1]*y; }
  dot3(g, x, y, z) { return g[0]*x + g[1]*y + g[2]*z; }
  noise2D(x, y) {
    const F2 = 0.5 * (Math.sqrt(3) - 1), G2 = (3 - Math.sqrt(3)) / 6;
    const s = (x + y) * F2;
    const i = Math.floor(x + s), j = Math.floor(y + s);
    const t = (i + j) * G2;
    const X0 = i - t, Y0 = j - t;
    const x0 = x - X0, y0 = y - Y0;
    const i1 = x0 > y0 ? 1 : 0, j1 = x0 > y0 ? 0 : 1;
    const x1 = x0 - i1 + G2, y1 = y0 - j1 + G2;
    const x2 = x0 - 1 + 2*G2, y2 = y0 - 1 + 2*G2;
    const ii = i & 255, jj = j & 255;
    const gi0 = this.p[ii + this.p[jj]] % 12;
    const gi1 = this.p[ii + i1 + this.p[jj + j1]] % 12;
    const gi2 = this.p[ii + 1 + this.p[jj + 1]] % 12;
    let n0 = 0, n1 = 0, n2 = 0;
    let t0 = 0.5 - x0*x0 - y0*y0;
    if (t0 > 0) { t0 *= t0; n0 = t0 * t0 * this.dot2(this.grad3[gi0], x0, y0); }
    let t1 = 0.5 - x1*x1 - y1*y1;
    if (t1 > 0) { t1 *= t1; n1 = t1 * t1 * this.dot2(this.grad3[gi1], x1, y1); }
    let t2 = 0.5 - x2*x2 - y2*y2;
    if (t2 > 0) { t2 *= t2; n2 = t2 * t2 * this.dot2(this.grad3[gi2], x2, y2); }
    return 70 * (n0 + n1 + n2);
  }
  noise3D(x, y, z) {
    const F3 = 1/3, G3 = 1/6;
    const s = (x+y+z)*F3;
    const i=Math.floor(x+s), j=Math.floor(y+s), k=Math.floor(z+s);
    const t=(i+j+k)*G3;
    const X0=i-t, Y0=j-t, Z0=k-t;
    const x0=x-X0, y0=y-Y0, z0=z-Z0;
    let i1,j1,k1,i2,j2,k2;
    if(x0>=y0){if(y0>=z0){i1=1;j1=0;k1=0;i2=1;j2=1;k2=0}else if(x0>=z0){i1=1;j1=0;k1=0;i2=1;j2=0;k2=1}else{i1=0;j1=0;k1=1;i2=1;j2=0;k2=1}}
    else{if(y0<z0){i1=0;j1=0;k1=1;i2=0;j2=1;k2=1}else if(x0<z0){i1=0;j1=1;k1=0;i2=0;j2=1;k2=1}else{i1=0;j1=1;k1=0;i2=1;j2=1;k2=0}}
    const x1=x0-i1+G3,y1=y0-j1+G3,z1=z0-k1+G3;
    const x2=x0-i2+2*G3,y2=y0-j2+2*G3,z2=z0-k2+2*G3;
    const x3=x0-1+3*G3,y3=y0-1+3*G3,z3=z0-1+3*G3;
    const ii=i&255,jj=j&255,kk=k&255;
    const gi0=this.p[ii+this.p[jj+this.p[kk]]]%12;
    const gi1=this.p[ii+i1+this.p[jj+j1+this.p[kk+k1]]]%12;
    const gi2=this.p[ii+i2+this.p[jj+j2+this.p[kk+k2]]]%12;
    const gi3=this.p[ii+1+this.p[jj+1+this.p[kk+1]]]%12;
    let n0=0,n1=0,n2=0,n3=0;
    let t0=0.6-x0*x0-y0*y0-z0*z0; if(t0>0){t0*=t0;n0=t0*t0*this.dot3(this.grad3[gi0],x0,y0,z0)}
    let t1=0.6-x1*x1-y1*y1-z1*z1; if(t1>0){t1*=t1;n1=t1*t1*this.dot3(this.grad3[gi1],x1,y1,z1)}
    let t2=0.6-x2*x2-y2*y2-z2*z2; if(t2>0){t2*=t2;n2=t2*t2*this.dot3(this.grad3[gi2],x2,y2,z2)}
    let t3=0.6-x3*x3-y3*y3-z3*z3; if(t3>0){t3*=t3;n3=t3*t3*this.dot3(this.grad3[gi3],x3,y3,z3)}
    return 32*(n0+n1+n2+n3);
  }
  fbm(x, y, octaves = 6, lac = 2, gain = 0.5) {
    let sum = 0, amp = 1, freq = 1, max = 0;
    for (let i = 0; i < octaves; i++) {
      sum += this.noise2D(x * freq, y * freq) * amp;
      max += amp; amp *= gain; freq *= lac;
    }
    return sum / max;
  }
  ridge(x, y, octaves = 6, lac = 2, gain = 0.5) {
    let sum = 0, amp = 1, freq = 1, prev = 1;
    for (let i = 0; i < octaves; i++) {
      let n = Math.abs(this.noise2D(x * freq, y * freq));
      n = 1 - n; n = n * n;
      sum += n * amp * prev; prev = n;
      amp *= gain; freq *= lac;
    }
    return sum;
  }
}

// ─── YosemiteHeightmap ───
// Loads real USGS elevation data from AWS Terrain Tiles, caches in IndexedDB
class YosemiteHeightmap {
  constructor() {
    this.ready = false;
    this.loading = false;
    this.data = null; // Float32Array of elevations in meters
    this.width = 768;  // 3 tiles × 256
    this.height = 512; // 2 tiles × 256
    // Geographic bounds of the 6-tile grid (zoom 12)
    this.latN = 37.788081;
    this.latS = 37.649034;
    this.lonW = -119.707031;
    this.lonE = -119.443359;
    // Game world origin = center of Yosemite Valley (37.7392°N, 119.5872°W)
    this.originLat = 37.7392;
    this.originLon = -119.5872;
    // Meters per degree at this latitude
    this.mPerDegLat = 111320;
    this.mPerDegLon = 111320 * Math.cos(this.originLat * Math.PI / 180);
    // Heightmap bounds in game-world meters relative to origin
    this.worldMinX = (this.lonW - this.originLon) * this.mPerDegLon; // west edge
    this.worldMaxX = (this.lonE - this.originLon) * this.mPerDegLon; // east edge
    this.worldMinZ = -(this.latN - this.originLat) * this.mPerDegLat; // north edge (neg Z = north)
    this.worldMaxZ = -(this.latS - this.originLat) * this.mPerDegLat; // south edge
    // Valley floor elevation — subtract so valley floor ≈ 0 in game
    this.baseElevation = 1200;
    this.vScale = 1.0;
    this.tiles = [
      { x: 686, y: 1583 }, { x: 687, y: 1583 }, { x: 688, y: 1583 },
      { x: 686, y: 1584 }, { x: 687, y: 1584 }, { x: 688, y: 1584 }
    ];
    this.DB_NAME = 'InfiniteFlight';
    this.STORE_NAME = 'terrain';
    this.CACHE_KEY = 'yosemite_heightmap_v1';
  }
  async load(onReady) {
    if (this.ready) { if (onReady) onReady(); return; }
    if (this.loading) return;
    this.loading = true;
    try {
      // Try IndexedDB cache first
      const cached = await this._loadFromCache();
      if (cached) {
        this.data = cached;
        this.ready = true;
        this.loading = false;
        console.log('Yosemite heightmap loaded from cache (' + this.data.length + ' points)');
        if (onReady) onReady();
        return;
      }
      // Fetch from AWS
      console.log('Fetching Yosemite terrain tiles from AWS...');
      const canvas = document.createElement('canvas');
      canvas.width = this.width;
      canvas.height = this.height;
      const ctx = canvas.getContext('2d', { willReadFrequently: true });
      const promises = this.tiles.map(async (tile, i) => {
        const url = `https://s3.amazonaws.com/elevation-tiles-prod/terrarium/12/${tile.x}/${tile.y}.png`;
        const img = new Image();
        img.crossOrigin = 'anonymous';
        await new Promise((resolve, reject) => {
          img.onload = resolve;
          img.onerror = reject;
          img.src = url;
        });
        const col = i % 3;
        const row = Math.floor(i / 3);
        ctx.drawImage(img, col * 256, row * 256);
      });
      await Promise.all(promises);
      // Decode Terrarium format: elevation = (R*256 + G + B/256) - 32768
      const imageData = ctx.getImageData(0, 0, this.width, this.height);
      const pixels = imageData.data;
      this.data = new Float32Array(this.width * this.height);
      for (let i = 0; i < this.width * this.height; i++) {
        const r = pixels[i * 4];
        const g = pixels[i * 4 + 1];
        const b = pixels[i * 4 + 2];
        this.data[i] = (r * 256 + g + b / 256) - 32768;
      }
      this.ready = true;
      this.loading = false;
      console.log('Yosemite heightmap decoded: ' + this.width + 'x' + this.height);
      if (onReady) onReady();
      // Save to IndexedDB for next time
      await this._saveToCache(this.data);
      console.log('Yosemite heightmap cached to IndexedDB');
    } catch (e) {
      console.warn('Failed to load Yosemite heightmap:', e);
      this.loading = false;
    }
  }
  getElevation(wx, wz) {
    if (!this.ready) return null;
    const u = (wx - this.worldMinX) / (this.worldMaxX - this.worldMinX);
    const v = (wz - this.worldMinZ) / (this.worldMaxZ - this.worldMinZ);
    if (u < 0 || u > 1 || v < 0 || v > 1) return null;
    const px = u * (this.width - 1);
    const py = v * (this.height - 1);
    // Bilinear interpolation for smooth terrain
    const x0 = Math.floor(px), y0 = Math.floor(py);
    const x1 = Math.min(x0 + 1, this.width - 1);
    const y1 = Math.min(y0 + 1, this.height - 1);
    const fx = px - x0, fy = py - y0;
    const h00 = this.data[y0 * this.width + x0];
    const h10 = this.data[y0 * this.width + x1];
    const h01 = this.data[y1 * this.width + x0];
    const h11 = this.data[y1 * this.width + x1];
    const elev = h00 * (1-fx)*(1-fy) + h10*fx*(1-fy) + h01*(1-fx)*fy + h11*fx*fy;
    return (elev - this.baseElevation) * this.vScale;
  }
  async _openDB() {
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(this.DB_NAME, 1);
      req.onupgradeneeded = () => {
        const db = req.result;
        if (!db.objectStoreNames.contains(this.STORE_NAME)) {
          db.createObjectStore(this.STORE_NAME);
        }
      };
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  }
  async _loadFromCache() {
    try {
      const db = await this._openDB();
      return new Promise((resolve) => {
        const tx = db.transaction(this.STORE_NAME, 'readonly');
        const store = tx.objectStore(this.STORE_NAME);
        const req = store.get(this.CACHE_KEY);
        req.onsuccess = () => {
          if (req.result) resolve(new Float32Array(req.result));
          else resolve(null);
        };
        req.onerror = () => resolve(null);
      });
    } catch (e) { return null; }
  }
  async _saveToCache(data) {
    try {
      const db = await this._openDB();
      const tx = db.transaction(this.STORE_NAME, 'readwrite');
      const store = tx.objectStore(this.STORE_NAME);
      store.put(data.buffer, this.CACHE_KEY);
    } catch (e) {
      console.warn('Could not cache heightmap:', e);
    }
  }
}

const yosemiteHeightmap = new YosemiteHeightmap();

// ─── Location Configs ───
const LOCATIONS = [
  { // 0: Tropical Islands
    name: 'Tropical Islands',
    noiseScale: 0.002, amplitude: 40, octaves: 5, lacunarity: 2.2, gain: 0.45, ridgeFactor: 0,
    plateauFactor: 0, waterLevel: 0, seaFloor: -15,
    colors: [
      { h: -15, color: [0.1, 0.15, 0.3] },
      { h: -1, color: [0.2, 0.5, 0.6] },
      { h: 0, color: [0.95, 0.9, 0.7] },
      { h: 3, color: [0.95, 0.85, 0.6] },
      { h: 8, color: [0.2, 0.7, 0.2] },
      { h: 20, color: [0.15, 0.55, 0.15] },
      { h: 40, color: [0.1, 0.4, 0.1] }
    ],
    skyTurbidity: 8, skyRayleigh: 1.5, skyMie: 0.005, skyMieG: 0.8,
    sunElevation: 45, sunAzimuth: 180,
    waterColor: 0x00bcd4, waterSunColor: 0xffffff, waterDistortion: 3.7,
    fogColor: 0x87ceeb, fogNear: 500, fogFar: 3500,
    treeTypes: ['palm'], treeDensity: 0.4, treeMinH: 3, treeMaxH: 25,
    startAlt: 150, landmark: null
  },
  { // 1: Rain Forest
    name: 'Rain Forest',
    noiseScale: 0.0015, amplitude: 60, octaves: 6, lacunarity: 2.1, gain: 0.5, ridgeFactor: 0.2,
    plateauFactor: 0, waterLevel: -5, seaFloor: -20,
    colors: [
      { h: -20, color: [0.05, 0.15, 0.1] },
      { h: -5, color: [0.1, 0.25, 0.15] },
      { h: 0, color: [0.08, 0.35, 0.08] },
      { h: 15, color: [0.06, 0.4, 0.06] },
      { h: 35, color: [0.04, 0.3, 0.04] },
      { h: 60, color: [0.08, 0.25, 0.08] }
    ],
    skyTurbidity: 12, skyRayleigh: 2.5, skyMie: 0.01, skyMieG: 0.7,
    sunElevation: 50, sunAzimuth: 160,
    waterColor: 0x1a4a2a, waterSunColor: 0xccddaa, waterDistortion: 2,
    fogColor: 0x4a6a4a, fogNear: 200, fogFar: 2000,
    treeTypes: ['deciduous', 'palm', 'shrub'], treeDensity: 0.8, treeMinH: -2, treeMaxH: 40,
    startAlt: 200, landmark: null
  },
  { // 2: Desert
    name: 'Desert',
    noiseScale: 0.001, amplitude: 80, octaves: 4, lacunarity: 2.5, gain: 0.4, ridgeFactor: 0,
    plateauFactor: 0.6, waterLevel: -100, seaFloor: -100,
    colors: [
      { h: 0, color: [0.9, 0.8, 0.5] },
      { h: 15, color: [0.85, 0.7, 0.4] },
      { h: 30, color: [0.8, 0.55, 0.3] },
      { h: 55, color: [0.7, 0.4, 0.25] },
      { h: 80, color: [0.6, 0.35, 0.2] }
    ],
    skyTurbidity: 20, skyRayleigh: 0.5, skyMie: 0.1, skyMieG: 0.95,
    sunElevation: 60, sunAzimuth: 200,
    waterColor: 0x000000, waterSunColor: 0x000000, waterDistortion: 0,
    fogColor: 0xd4a060, fogNear: 800, fogFar: 4000,
    treeTypes: ['shrub'], treeDensity: 0.03, treeMinH: 0, treeMaxH: 20,
    startAlt: 200, landmark: null
  },
  { // 3: Redwood Forest
    name: 'Redwood Forest',
    noiseScale: 0.002, amplitude: 35, octaves: 5, lacunarity: 2, gain: 0.5, ridgeFactor: 0,
    plateauFactor: 0, waterLevel: -100, seaFloor: -100,
    colors: [
      { h: 0, color: [0.15, 0.25, 0.1] },
      { h: 8, color: [0.12, 0.3, 0.08] },
      { h: 18, color: [0.1, 0.22, 0.06] },
      { h: 35, color: [0.08, 0.18, 0.05] }
    ],
    skyTurbidity: 10, skyRayleigh: 3, skyMie: 0.005, skyMieG: 0.8,
    sunElevation: 35, sunAzimuth: 170,
    waterColor: 0x000000, waterSunColor: 0x000000, waterDistortion: 0,
    fogColor: 0x556b55, fogNear: 100, fogFar: 1500,
    treeTypes: ['redwood', 'conifer', 'shrub'], treeDensity: 0.7, treeMinH: 0, treeMaxH: 30,
    startAlt: 200, landmark: null
  },
  { // 4: Yosemite
    name: 'Yosemite',
    noiseScale: 0.0006, amplitude: 350, octaves: 7, lacunarity: 2, gain: 0.55, ridgeFactor: 0.6,
    plateauFactor: 0, waterLevel: -5, seaFloor: -20,
    useRealTerrain: 'yosemite',
    colors: [
      { h: -20, color: [0.08, 0.15, 0.25] },
      { h: -2, color: [0.1, 0.25, 0.35] },
      { h: 0, color: [0.12, 0.32, 0.08] },
      { h: 20, color: [0.18, 0.42, 0.12] },
      { h: 50, color: [0.22, 0.38, 0.14] },
      { h: 90, color: [0.55, 0.52, 0.47] },
      { h: 140, color: [0.68, 0.66, 0.62] },
      { h: 200, color: [0.78, 0.76, 0.72] },
      { h: 260, color: [0.85, 0.83, 0.8] },
      { h: 320, color: [0.95, 0.94, 0.92] }
    ],
    skyTurbidity: 4, skyRayleigh: 2.2, skyMie: 0.003, skyMieG: 0.8,
    sunElevation: 38, sunAzimuth: 200,
    waterColor: 0x1a4a3a, waterSunColor: 0xddddbb, waterDistortion: 1.0,
    fogColor: 0x7a8a9a, fogNear: 600, fogFar: 4000,
    treeTypes: ['conifer', 'deciduous'], treeDensity: 0.4, treeMinH: -5, treeMaxH: 80,
    startAlt: 400, landmark: 'waterfall'
  },
  { // 5: SF Bay
    name: 'SF Bay',
    noiseScale: 0.002, amplitude: 50, octaves: 5, lacunarity: 2, gain: 0.5, ridgeFactor: 0.2,
    plateauFactor: 0, waterLevel: 0, seaFloor: -20,
    colors: [
      { h: -20, color: [0.1, 0.15, 0.25] },
      { h: -1, color: [0.15, 0.2, 0.3] },
      { h: 0, color: [0.7, 0.65, 0.5] },
      { h: 5, color: [0.4, 0.5, 0.3] },
      { h: 20, color: [0.35, 0.45, 0.25] },
      { h: 50, color: [0.5, 0.45, 0.35] }
    ],
    skyTurbidity: 10, skyRayleigh: 1.8, skyMie: 0.008, skyMieG: 0.85,
    sunElevation: 42, sunAzimuth: 210,
    waterColor: 0x1a3a5a, waterSunColor: 0xddddcc, waterDistortion: 2.5,
    fogColor: 0x8899aa, fogNear: 400, fogFar: 3500,
    treeTypes: ['deciduous', 'shrub'], treeDensity: 0.15, treeMinH: 2, treeMaxH: 30,
    startAlt: 200, landmark: 'golden_gate'
  },
  { // 6: Chicago
    name: 'Chicago',
    noiseScale: 0.003, amplitude: 8, octaves: 3, lacunarity: 2, gain: 0.4, ridgeFactor: 0,
    plateauFactor: 0, waterLevel: 0, seaFloor: -30,
    colors: [
      { h: -30, color: [0.15, 0.2, 0.3] },
      { h: -1, color: [0.2, 0.25, 0.35] },
      { h: 0, color: [0.35, 0.4, 0.3] },
      { h: 3, color: [0.3, 0.42, 0.2] },
      { h: 8, color: [0.25, 0.35, 0.18] }
    ],
    skyTurbidity: 8, skyRayleigh: 1.5, skyMie: 0.005, skyMieG: 0.8,
    sunElevation: 38, sunAzimuth: 200,
    waterColor: 0x2a4a6a, waterSunColor: 0xcccccc, waterDistortion: 2,
    fogColor: 0x7a8a9a, fogNear: 500, fogFar: 4000,
    treeTypes: ['deciduous'], treeDensity: 0.08, treeMinH: 1, treeMaxH: 6,
    startAlt: 200, landmark: 'skyline_chicago'
  },
  { // 7: Bellagio / Lake Como
    name: 'Bellagio / Lake Como',
    noiseScale: 0.001, amplitude: 180, octaves: 6, lacunarity: 2.1, gain: 0.5, ridgeFactor: 0.4,
    plateauFactor: 0, waterLevel: 0, seaFloor: -40,
    colors: [
      { h: -40, color: [0.05, 0.1, 0.25] },
      { h: -1, color: [0.1, 0.18, 0.35] },
      { h: 0, color: [0.4, 0.5, 0.3] },
      { h: 15, color: [0.3, 0.5, 0.2] },
      { h: 50, color: [0.25, 0.4, 0.15] },
      { h: 100, color: [0.5, 0.48, 0.4] },
      { h: 150, color: [0.7, 0.68, 0.65] },
      { h: 180, color: [0.9, 0.9, 0.88] }
    ],
    skyTurbidity: 6, skyRayleigh: 2, skyMie: 0.004, skyMieG: 0.8,
    sunElevation: 45, sunAzimuth: 175,
    waterColor: 0x0a2a5a, waterSunColor: 0xeeeedd, waterDistortion: 1.5,
    fogColor: 0x7a8a9a, fogNear: 400, fogFar: 3000,
    treeTypes: ['conifer', 'deciduous', 'shrub'], treeDensity: 0.4, treeMinH: 2, treeMaxH: 80,
    startAlt: 250, landmark: 'villas'
  }
];

// ─── Aircraft Configs ───
const AIRCRAFT = [
  { name:'Biplane', maxSpeed:55, thrust:25, drag:0.015, liftFactor:1.2, pitchRate:1.2, rollRate:2.0, yawRate:0.3, hasEngine:true },
  { name:'Cessna', maxSpeed:75, thrust:35, drag:0.012, liftFactor:1.0, pitchRate:1.0, rollRate:1.8, yawRate:0.25, hasEngine:true },
  { name:'Glider', maxSpeed:60, thrust:0, drag:0.006, liftFactor:1.8, pitchRate:0.8, rollRate:2.2, yawRate:0.2, hasEngine:false },
  { name:'Paraglider', maxSpeed:18, thrust:0, drag:0.04, liftFactor:2.5, pitchRate:0.5, rollRate:1.0, yawRate:0.4, hasEngine:false },
  { name:'Hang Glider', maxSpeed:28, thrust:0, drag:0.02, liftFactor:2.0, pitchRate:0.6, rollRate:1.5, yawRate:0.35, hasEngine:false },
  { name:'F-117 Nighthawk', maxSpeed:280, thrust:120, drag:0.008, liftFactor:0.7, pitchRate:1.4, rollRate:2.5, yawRate:0.3, hasEngine:true, hasAfterburner:true },
  { name:'F-14 Tomcat', maxSpeed:350, thrust:160, drag:0.007, liftFactor:0.8, pitchRate:1.6, rollRate:3.0, yawRate:0.35, hasEngine:true, hasAfterburner:true }
];

const CHUNK_SIZE = 512;
const GRID_RADIUS = 3; // 7x7 grid

// ─── TerrainSystem ───
class TerrainSystem {
  constructor(scene, noise) {
    this.scene = scene;
    this.noise = noise;
    this.chunks = new Map();
    this.pool = [];
    this.loc = LOCATIONS[0];
  }
  setLocation(loc) {
    this.loc = loc;
    this.clearAll();
    // Load real terrain heightmap if needed (async — chunks regenerate when ready)
    if (loc.useRealTerrain === 'yosemite') {
      yosemiteHeightmap.load(() => this.clearAll());
    }
  }
  clearAll() {
    this.chunks.forEach(c => { this.scene.remove(c.mesh); c.mesh.geometry.dispose(); });
    this.chunks.clear();
  }
  getHeight(wx, wz) {
    const L = this.loc;
    let h = this.noise.fbm(wx * L.noiseScale, wz * L.noiseScale, L.octaves, L.lacunarity, L.gain);
    if (L.ridgeFactor > 0) {
      const r = this.noise.ridge(wx * L.noiseScale * 0.7, wz * L.noiseScale * 0.7, 5);
      h = h * (1 - L.ridgeFactor) + r * L.ridgeFactor;
    }
    h *= L.amplitude;
    if (L.plateauFactor > 0) {
      const plateauH = L.amplitude * 0.5;
      const blend = Math.max(0, Math.min(1, (h - plateauH * 0.5) / (plateauH * 0.3)));
      h = h * (1 - blend * L.plateauFactor) + plateauH * blend * L.plateauFactor;
    }
    if (h < L.seaFloor) h = L.seaFloor;
    // Real terrain heightmap override (e.g. Yosemite)
    if (L.useRealTerrain === 'yosemite' && yosemiteHeightmap.ready) {
      const realH = yosemiteHeightmap.getElevation(wx, wz);
      if (realH !== null) return realH;
      // Outside heightmap bounds: blend procedural terrain up to rim level
    }
    return h;
  }
  getColorForHeight(h) {
    const colors = this.loc.colors;
    if (h <= colors[0].h) return colors[0].color;
    if (h >= colors[colors.length-1].h) return colors[colors.length-1].color;
    for (let i = 0; i < colors.length - 1; i++) {
      if (h >= colors[i].h && h < colors[i+1].h) {
        const t = (h - colors[i].h) / (colors[i+1].h - colors[i].h);
        const a = colors[i].color, b = colors[i+1].color;
        return [a[0]+(b[0]-a[0])*t, a[1]+(b[1]-a[1])*t, a[2]+(b[2]-a[2])*t];
      }
    }
    return colors[0].color;
  }
  generateChunk(cx, cz) {
    const key = cx + ',' + cz;
    if (this.chunks.has(key)) return;
    const dist = Math.max(Math.abs(cx - this._pcx), Math.abs(cz - this._pcz));
    const segs = dist <= 1 ? 128 : dist <= 2 ? 64 : 32;
    const geo = new THREE.PlaneGeometry(CHUNK_SIZE, CHUNK_SIZE, segs, segs);
    geo.rotateX(-Math.PI / 2);
    const pos = geo.attributes.position;
    const colArr = new Float32Array(pos.count * 3);
    const ox = cx * CHUNK_SIZE, oz = cz * CHUNK_SIZE;
    for (let i = 0; i < pos.count; i++) {
      const wx = pos.getX(i) + ox;
      const wz = pos.getZ(i) + oz;
      const h = this.getHeight(wx, wz);
      pos.setY(i, h);
      const noiseVar = this.noise.noise2D(wx * 0.05, wz * 0.05) * 0.05;
      const noiseVar2 = this.noise.noise2D(wx * 0.02 + 100, wz * 0.02 + 100) * 0.03;
      const c = this.getColorForHeight(h);
      // Slope-based rock/cliff coloring
      const step = 2;
      const hL = this.getHeight(wx - step, wz);
      const hR = this.getHeight(wx + step, wz);
      const hU = this.getHeight(wx, wz - step);
      const hD = this.getHeight(wx, wz + step);
      const slope = Math.sqrt(Math.pow((hR - hL) / (2*step), 2) + Math.pow((hD - hU) / (2*step), 2));
      const slopeFactor = Math.min(1, slope * 0.8);
      const rockColor = [0.5, 0.48, 0.42];
      colArr[i*3] = Math.max(0, Math.min(1, c[0] * (1 - slopeFactor) + rockColor[0] * slopeFactor + noiseVar + noiseVar2));
      colArr[i*3+1] = Math.max(0, Math.min(1, c[1] * (1 - slopeFactor) + rockColor[1] * slopeFactor + noiseVar + noiseVar2));
      colArr[i*3+2] = Math.max(0, Math.min(1, c[2] * (1 - slopeFactor) + rockColor[2] * slopeFactor + noiseVar + noiseVar2));
    }
    geo.setAttribute('color', new THREE.BufferAttribute(colArr, 3));
    geo.computeVertexNormals();
    const mat = new THREE.MeshStandardMaterial({ vertexColors: true, roughness: 0.85, metalness: 0.05 });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(ox, 0, oz);
    this.scene.add(mesh);
    this.chunks.set(key, { mesh, cx, cz });
  }
  update(px, pz) {
    this._pcx = Math.round(px / CHUNK_SIZE);
    this._pcz = Math.round(pz / CHUNK_SIZE);
    let generated = 0;
    for (let dx = -GRID_RADIUS; dx <= GRID_RADIUS; dx++) {
      for (let dz = -GRID_RADIUS; dz <= GRID_RADIUS; dz++) {
        const cx = this._pcx + dx, cz = this._pcz + dz;
        const key = cx + ',' + cz;
        if (!this.chunks.has(key)) {
          if (generated < 1) { this.generateChunk(cx, cz); generated++; }
        }
      }
    }
    const remove = [];
    this.chunks.forEach((c, key) => {
      if (Math.abs(c.cx - this._pcx) > GRID_RADIUS + 1 || Math.abs(c.cz - this._pcz) > GRID_RADIUS + 1)
        remove.push(key);
    });
    remove.forEach(key => {
      const c = this.chunks.get(key);
      this.scene.remove(c.mesh); c.mesh.geometry.dispose(); c.mesh.material.dispose();
      this.chunks.delete(key);
    });
  }
}

// ─── WaterSystem ───
class WaterSystem {
  constructor(scene, noise) {
    this.scene = scene;
    this.noise = noise;
    this.water = null;
  }
  generateNormalMap() {
    const size = 256;
    const canvas = document.createElement('canvas');
    canvas.width = size; canvas.height = size;
    const ctx = canvas.getContext('2d');
    const img = ctx.createImageData(size, size);
    for (let y = 0; y < size; y++) {
      for (let x = 0; x < size; x++) {
        const i = (y * size + x) * 4;
        const nx = this.noise.noise2D(x / 20, y / 20) * 0.5 + 0.5;
        const ny = this.noise.noise2D(x / 20 + 50, y / 20 + 50) * 0.5 + 0.5;
        img.data[i] = nx * 255;
        img.data[i+1] = ny * 255;
        img.data[i+2] = 255;
        img.data[i+3] = 255;
      }
    }
    ctx.putImageData(img, 0, 0);
    const tex = new THREE.CanvasTexture(canvas);
    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
    return tex;
  }
  create(loc) {
    if (this.water) { this.scene.remove(this.water); this.water.geometry.dispose(); }
    if (loc.waterLevel <= -100) { this.water = null; return; }
    const geo = new THREE.PlaneGeometry(8000, 8000);
    this.water = new Water(geo, {
      textureWidth: 256, textureHeight: 256,
      waterNormals: this.generateNormalMap(),
      sunDirection: new THREE.Vector3(),
      sunColor: loc.waterSunColor,
      waterColor: loc.waterColor,
      distortionScale: loc.waterDistortion,
      fog: true
    });
    this.water.rotation.x = -Math.PI / 2;
    this.water.position.y = loc.waterLevel;
    this.scene.add(this.water);
  }
  update(dt, px, pz) {
    if (!this.water) return;
    this.water.material.uniforms['time'].value += dt * 0.5;
    this.water.position.x = Math.round(px / 500) * 500;
    this.water.position.z = Math.round(pz / 500) * 500;
  }
}

// ─── SkyAtmosphere ───
class SkyAtmosphere {
  constructor(scene) {
    this.scene = scene;
    this.sky = new Sky();
    this.sky.scale.setScalar(10000);
    scene.add(this.sky);
    this.sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
    scene.add(this.sunLight);
    scene.add(new THREE.AmbientLight(0x404040, 1.0));
  }
  configure(loc) {
    const u = this.sky.material.uniforms;
    u['turbidity'].value = loc.skyTurbidity;
    u['rayleigh'].value = loc.skyRayleigh;
    u['mieCoefficient'].value = loc.skyMie;
    u['mieDirectionalG'].value = loc.skyMieG;
    const phi = THREE.MathUtils.degToRad(90 - loc.sunElevation);
    const theta = THREE.MathUtils.degToRad(loc.sunAzimuth);
    const sun = new THREE.Vector3().setFromSphericalCoords(1, phi, theta);
    u['sunPosition'].value.copy(sun);
    this.sunLight.position.copy(sun.clone().multiplyScalar(1000));
    this.sunLight.color.setHex(loc.sunElevation > 30 ? 0xfff8e0 : 0xffaa66);
    if (this.water) {
      this.water.material.uniforms['sunDirection'].value.copy(sun);
    }
    this.scene.fog = new THREE.Fog(loc.fogColor, loc.fogNear, loc.fogFar);
  }
  setSunOnWater(water) {
    this.water = water;
  }
}

// ─── VegetationSystem ───
class VegetationSystem {
  constructor(scene, noise) {
    this.scene = scene;
    this.noise = noise;
    this.chunkTrees = new Map();
    this.treeGeos = {};
    this.treeMats = {};
    this.buildGeometries();
  }
  mergeGeos(geos) {
    let totalVerts = 0;
    geos.forEach(g => { totalVerts += g.attributes.position.count; });
    const merged = new THREE.BufferGeometry();
    const pos = new Float32Array(totalVerts * 3);
    const norm = new Float32Array(totalVerts * 3);
    const col = new Float32Array(totalVerts * 3);
    let vOff = 0;
    const indices = [];
    geos.forEach(g => {
      const p = g.attributes.position;
      if (!g.attributes.normal) g.computeVertexNormals();
      const nn = g.attributes.normal;
      const cc = g.attributes.color;
      for (let i = 0; i < p.count; i++) {
        pos[(vOff+i)*3] = p.getX(i);
        pos[(vOff+i)*3+1] = p.getY(i);
        pos[(vOff+i)*3+2] = p.getZ(i);
        if (nn) { norm[(vOff+i)*3] = nn.getX(i); norm[(vOff+i)*3+1] = nn.getY(i); norm[(vOff+i)*3+2] = nn.getZ(i); }
        if (cc) { col[(vOff+i)*3] = cc.getX(i); col[(vOff+i)*3+1] = cc.getY(i); col[(vOff+i)*3+2] = cc.getZ(i); }
        else { col[(vOff+i)*3] = 0.5; col[(vOff+i)*3+1] = 0.5; col[(vOff+i)*3+2] = 0.5; }
      }
      if (g.index) { for (let i = 0; i < g.index.count; i++) indices.push(g.index.array[i] + vOff); }
      else { for (let i = 0; i < p.count; i++) indices.push(vOff + i); }
      vOff += p.count;
    });
    merged.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    merged.setAttribute('normal', new THREE.BufferAttribute(norm, 3));
    merged.setAttribute('color', new THREE.BufferAttribute(col, 3));
    merged.setIndex(indices);
    return merged;
  }
  applyVertexColors(geo, colorFn) {
    const pos = geo.attributes.position;
    const colors = new Float32Array(pos.count * 3);
    for (let i = 0; i < pos.count; i++) {
      const y = pos.getY(i);
      const c = colorFn(pos.getX(i), y, pos.getZ(i));
      colors[i*3] = c[0]; colors[i*3+1] = c[1]; colors[i*3+2] = c[2];
    }
    geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
  }
  buildGeometries() {
    const vcMat = new THREE.MeshStandardMaterial({ vertexColors: true, roughness: 0.8 });
    // ─── Palm ───
    const palmTrunk = new THREE.CylinderGeometry(0.25, 0.5, 12, 7);
    // Bend trunk slightly
    const ptp = palmTrunk.attributes.position;
    for (let i = 0; i < ptp.count; i++) {
      const y = ptp.getY(i);
      const bend = Math.pow(Math.max(0, y) / 12, 2) * 1.5;
      ptp.setX(i, ptp.getX(i) + bend);
    }
    this.applyVertexColors(palmTrunk, (x,y,z) => {
      const t = (y + 6) / 12;
      return [0.35 + t*0.1, 0.22 + t*0.05, 0.08];
    });
    const palmFronds = [];
    for (let f = 0; f < 7; f++) {
      const angle = (f / 7) * Math.PI * 2;
      const frond = new THREE.PlaneGeometry(1.0, 5, 1, 4);
      frond.rotateX(-Math.PI/2);
      const fp = frond.attributes.position;
      for (let i = 0; i < fp.count; i++) {
        const z = fp.getZ(i);
        fp.setX(i, fp.getX(i) * (1 - Math.abs(z)/5 * 0.7));
        fp.setY(i, -Math.pow(Math.abs(z)/5, 2) * 3);
      }
      frond.rotateY(angle);
      frond.translate(Math.sin(angle)*1.5, 6.5, Math.cos(angle)*1.5);
      this.applyVertexColors(frond, (x,y,z) => {
        const tip = Math.sqrt(x*x+z*z) / 5;
        return [0.1 + tip*0.15, 0.55 + tip*0.15 + Math.random()*0.05, 0.05];
      });
      palmFronds.push(frond);
    }
    this.treeGeos.palm = this.mergeGeos([palmTrunk, ...palmFronds]);
    this.treeMats.palm = vcMat;

    // ─── Deciduous ───
    const decTrunk = new THREE.CylinderGeometry(0.2, 0.5, 6, 6);
    this.applyVertexColors(decTrunk, (x,y,z) => [0.3 - y*0.02, 0.2 - y*0.01, 0.1]);
    const decBranches = [];
    for (let b = 0; b < 3; b++) {
      const angle = (b / 3) * Math.PI * 2 + 0.5;
      const branch = new THREE.CylinderGeometry(0.06, 0.12, 3, 4);
      branch.rotateZ(0.5 * (b % 2 === 0 ? 1 : -1));
      branch.rotateY(angle);
      branch.translate(Math.sin(angle)*1.2, 4.5 + b*0.5, Math.cos(angle)*1.2);
      this.applyVertexColors(branch, () => [0.32, 0.22, 0.12]);
      decBranches.push(branch);
    }
    const decCanopies = [];
    const canopyPositions = [[0, 6, 0], [-1.5, 5.5, 0.8], [1.2, 5.8, -1], [0.3, 7, 0.5], [-0.8, 6.5, -1.2]];
    canopyPositions.forEach(([cx, cy, cz], i) => {
      const r = 1.5 + Math.sin(i * 2.3) * 0.5;
      const canopy = new THREE.SphereGeometry(r, 6, 5);
      canopy.translate(cx, cy, cz);
      this.applyVertexColors(canopy, (x,y,z) => {
        const t = (y - cy + r) / (r * 2);
        const variant = (i * 0.15) % 0.3;
        return [0.12 + variant, 0.4 + t * 0.2 + variant, 0.08 + variant * 0.5];
      });
      decCanopies.push(canopy);
    });
    this.treeGeos.deciduous = this.mergeGeos([decTrunk, ...decBranches, ...decCanopies]);
    this.treeMats.deciduous = vcMat;

    // ─── Conifer ───
    const conTrunk = new THREE.CylinderGeometry(0.15, 0.35, 6, 5);
    this.applyVertexColors(conTrunk, (x,y,z) => [0.3, 0.18, 0.08]);
    const conTiers = [];
    for (let t = 0; t < 4; t++) {
      const radius = 2.8 - t * 0.6;
      const h = 2.5 - t * 0.3;
      const tier = new THREE.ConeGeometry(radius, h, 7);
      tier.translate(0, 4 + t * 2.2, 0);
      this.applyVertexColors(tier, (x,y,z) => {
        const tip = y / 12;
        return [0.05 + t*0.02, 0.25 + tip*0.15 + t*0.04, 0.1 + t*0.03];
      });
      conTiers.push(tier);
    }
    this.treeGeos.conifer = this.mergeGeos([conTrunk, ...conTiers]);
    this.treeMats.conifer = vcMat;

    // ─── Redwood ───
    const rwTrunk = new THREE.CylinderGeometry(0.8, 2.0, 30, 8);
    rwTrunk.translate(0, 15, 0);
    this.applyVertexColors(rwTrunk, (x,y,z) => {
      const t = y / 30;
      return [0.35 + t*0.1, 0.15 + t*0.05, 0.05];
    });
    const rwButtress = [];
    for (let b = 0; b < 5; b++) {
      const angle = (b / 5) * Math.PI * 2;
      const root = new THREE.CylinderGeometry(0.1, 0.5, 4, 4);
      root.rotateZ(0.4);
      root.rotateY(angle);
      root.translate(Math.sin(angle)*1.8, 1.5, Math.cos(angle)*1.8);
      this.applyVertexColors(root, () => [0.3, 0.15, 0.05]);
      rwButtress.push(root);
    }
    const rwCanopy = new THREE.SphereGeometry(4, 6, 5);
    rwCanopy.translate(0, 32, 0);
    this.applyVertexColors(rwCanopy, (x,y,z) => [0.1, 0.3 + (y-28)*0.02, 0.08]);
    const rwCanopy2 = new THREE.SphereGeometry(3, 6, 4);
    rwCanopy2.translate(1.5, 30, 1);
    this.applyVertexColors(rwCanopy2, (x,y,z) => [0.12, 0.28, 0.06]);
    this.treeGeos.redwood = this.mergeGeos([rwTrunk, ...rwButtress, rwCanopy, rwCanopy2]);
    this.treeMats.redwood = vcMat;

    // ─── Shrub ───
    const shrubParts = [];
    const shrubOffsets = [[0,0.6,0],[0.5,0.5,0.3],[-0.4,0.4,-0.3],[0.2,0.8,0.4]];
    shrubOffsets.forEach(([sx,sy,sz], i) => {
      const s = new THREE.SphereGeometry(0.7 + i*0.15, 5, 4);
      s.translate(sx, sy, sz);
      this.applyVertexColors(s, (x,y,z) => {
        const v = i * 0.08;
        return [0.2 + v, 0.4 + v + y*0.05, 0.15 + v];
      });
      shrubParts.push(s);
    });
    this.treeGeos.shrub = this.mergeGeos(shrubParts);
    this.treeMats.shrub = vcMat;

    // ─── Grass clumps ───
    const grassBlades = [];
    for (let g = 0; g < 5; g++) {
      const blade = new THREE.PlaneGeometry(0.15, 0.6, 1, 2);
      blade.rotateY(g * 1.2);
      blade.translate((g-2)*0.2, 0.3, (g%3-1)*0.15);
      this.applyVertexColors(blade, (x,y,z) => [0.15, 0.35 + y*0.3, 0.08]);
      grassBlades.push(blade);
    }
    this.treeGeos.grass = this.mergeGeos(grassBlades);
    this.treeMats.grass = new THREE.MeshStandardMaterial({ vertexColors: true, roughness: 0.9, side: THREE.DoubleSide });
  }
  clearAll() {
    this.chunkTrees.forEach(meshes => meshes.forEach(m => { this.scene.remove(m); m.geometry.dispose(); }));
    this.chunkTrees.clear();
  }
  generateForChunk(cx, cz, loc, terrain) {
    const key = cx + ',' + cz;
    if (this.chunkTrees.has(key)) return;
    if (!loc.treeTypes || loc.treeTypes.length === 0) return;
    const meshes = [];
    const ox = cx * CHUNK_SIZE, oz = cz * CHUNK_SIZE;
    const maxPerType = 350;
    const allTypes = [...loc.treeTypes];
    if (loc.treeDensity > 0.15 && !allTypes.includes('grass')) allTypes.push('grass');
    allTypes.forEach(type => {
      const isGrass = type === 'grass';
      const count = isGrass ? maxPerType * 3 : maxPerType;
      const positions = [];
      const step = CHUNK_SIZE / Math.sqrt(count * loc.treeDensity);
      for (let x = -CHUNK_SIZE/2; x < CHUNK_SIZE/2; x += step) {
        for (let z = -CHUNK_SIZE/2; z < CHUNK_SIZE/2; z += step) {
          const wx = ox + x + this.noise.noise2D(x*0.1+cx*99, z*0.1+cz*77) * step * 0.4;
          const wz = oz + z + this.noise.noise2D(x*0.1+cx*33, z*0.1+cz*55) * step * 0.4;
          const density = (this.noise.noise2D(wx * 0.008, wz * 0.008) + 1) * 0.5;
          if (density < (1 - loc.treeDensity)) continue;
          const h = terrain.getHeight(wx, wz);
          if (h < loc.treeMinH || h > loc.treeMaxH) continue;
          if (h < (loc.waterLevel || -100) + 1) continue;
          const scale = isGrass ? 0.5 + Math.random()*0.5 : 0.7 + this.noise.noise2D(wx*0.3, wz*0.3) * 0.5;
          positions.push({ x: wx, y: h, z: wz, s: Math.max(0.3, scale) });
        }
      }
      if (positions.length === 0) return;
      const geo = this.treeGeos[type];
      const mat = this.treeMats[type];
      if (!geo) return;
      const inst = new THREE.InstancedMesh(geo, mat, positions.length);
      const dummy = new THREE.Object3D();
      positions.forEach((p, i) => {
        dummy.position.set(p.x, p.y, p.z);
        dummy.scale.setScalar(p.s);
        dummy.rotation.y = p.x * 3.7 % (Math.PI * 2);
        dummy.updateMatrix();
        inst.setMatrixAt(i, dummy.matrix);
      });
      inst.instanceMatrix.needsUpdate = true;
      inst.frustumCulled = false;
      this.scene.add(inst);
      meshes.push(inst);
    });
    this.chunkTrees.set(key, meshes);
  }
  pruneChunks(pcx, pcz) {
    const remove = [];
    this.chunkTrees.forEach((meshes, key) => {
      const [cx, cz] = key.split(',').map(Number);
      if (Math.abs(cx - pcx) > GRID_RADIUS + 1 || Math.abs(cz - pcz) > GRID_RADIUS + 1)
        remove.push(key);
    });
    remove.forEach(key => {
      this.chunkTrees.get(key).forEach(m => { this.scene.remove(m); });
      this.chunkTrees.delete(key);
    });
  }
}

// ─── LandmarkSystem ───
class LandmarkSystem {
  constructor(scene) {
    this.scene = scene;
    this.objects = [];
  }
  clear() {
    this.objects.forEach(o => this.scene.remove(o));
    this.objects = [];
  }
  build(loc, terrain) {
    this.clear();
    if (loc.landmark === 'golden_gate') this.buildGoldenGate(terrain);
    else if (loc.landmark === 'waterfall') this.buildWaterfall(terrain);
    else if (loc.landmark === 'skyline_chicago') this.buildSkyline(terrain, 0x6688aa);
    else if (loc.landmark === 'villas') this.buildVillas(terrain);
  }
  addObj(obj) { this.scene.add(obj); this.objects.push(obj); }
  buildGoldenGate(terrain) {
    const bridgeMat = new THREE.MeshStandardMaterial({ color: 0xcc3300, roughness: 0.5, metalness: 0.3 });
    const cableMat = new THREE.MeshStandardMaterial({ color: 0xaa2200, roughness: 0.4, metalness: 0.5 });
    const roadMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.9 });
    const towerH = 120, towerW = 6, span = 400, roadY = 30;
    for (let side = -1; side <= 1; side += 2) {
      const tower = new THREE.Mesh(new THREE.BoxGeometry(towerW, towerH, towerW), bridgeMat);
      tower.position.set(side * span/2, towerH/2, 200);
      this.addObj(tower);
      const crossbar = new THREE.Mesh(new THREE.BoxGeometry(towerW * 3, 4, towerW), bridgeMat);
      crossbar.position.set(side * span/2, towerH * 0.75, 200);
      this.addObj(crossbar);
      const crossbar2 = new THREE.Mesh(new THREE.BoxGeometry(towerW * 3, 4, towerW), bridgeMat);
      crossbar2.position.set(side * span/2, towerH * 0.4, 200);
      this.addObj(crossbar2);
    }
    const road = new THREE.Mesh(new THREE.BoxGeometry(span + 200, 2, 18), roadMat);
    road.position.set(0, roadY, 200);
    this.addObj(road);
    for (let i = -20; i <= 20; i++) {
      const x = i * (span / 40);
      const sag = Math.pow(Math.abs(i) / 20, 2) * -30;
      const cable = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, Math.abs(towerH * 0.75 - roadY + sag), 4), cableMat);
      cable.position.set(x, (towerH * 0.75 + roadY + sag) / 2, 200 - 7);
      this.addObj(cable);
      const cable2 = cable.clone();
      cable2.position.z = 200 + 7;
      this.addObj(cable2);
    }
  }
  buildWaterfall(terrain) {
    const cliffMat = new THREE.MeshStandardMaterial({ color: 0x888880, roughness: 0.9 });
    const waterMat = new THREE.MeshStandardMaterial({ color: 0xaaddff, transparent: true, opacity: 0.6, roughness: 0.2 });
    const cliff = new THREE.Mesh(new THREE.BoxGeometry(60, 200, 40), cliffMat);
    cliff.position.set(0, 100, 300);
    this.addObj(cliff);
    const fall = new THREE.Mesh(new THREE.PlaneGeometry(15, 180), waterMat);
    fall.position.set(0, 90, 280);
    this.addObj(fall);
    const mist = new THREE.Mesh(
      new THREE.SphereGeometry(25, 8, 6),
      new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.15 })
    );
    mist.position.set(0, 10, 275);
    this.addObj(mist);
  }
  buildSkyline(terrain, tint) {
    const group = new THREE.Group();
    const mat = new THREE.MeshStandardMaterial({ color: tint, roughness: 0.4, metalness: 0.6 });
    for (let i = 0; i < 40; i++) {
      const w = 10 + Math.random() * 20;
      const h = 30 + Math.random() * 150;
      const d = 10 + Math.random() * 20;
      const bld = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mat);
      bld.position.set(-200 + Math.random() * 400, h / 2, 300 + Math.random() * 200);
      group.add(bld);
    }
    this.scene.add(group);
    this.objects.push(group);
  }
  buildVillas(terrain) {
    const wallMat = new THREE.MeshStandardMaterial({ color: 0xf5e6c8, roughness: 0.8 });
    const roofMat = new THREE.MeshStandardMaterial({ color: 0xcc6633, roughness: 0.7 });
    for (let i = 0; i < 15; i++) {
      const x = -150 + Math.random() * 300;
      const z = 100 + Math.random() * 300;
      const h = terrain.getHeight(x, z);
      if (h < 2 || h > 60) continue;
      const w = 8 + Math.random() * 8;
      const bh = 6 + Math.random() * 4;
      const wall = new THREE.Mesh(new THREE.BoxGeometry(w, bh, w), wallMat);
      wall.position.set(x, h + bh/2, z);
      this.addObj(wall);
      const roof = new THREE.Mesh(new THREE.ConeGeometry(w * 0.75, 4, 4), roofMat);
      roof.position.set(x, h + bh + 2, z);
      roof.rotation.y = Math.PI / 4;
      this.addObj(roof);
    }
  }
}

// ─── CockpitRenderer ───
class CockpitRenderer {
  constructor(camera) {
    this.camera = camera;
    this.group = new THREE.Group();
    camera.add(this.group);
    this.currentAircraft = -1;
  }
  updateInstruments(physics) {
    const speed = physics.speed;
    const alt = physics.position.y;
    const hdg = physics.getHeading();
    const setNeedle = (name, angle) => {
      const n = this.group.getObjectByName(name);
      if (n) n.rotation.z = angle;
    };
    // Speed: 0-80 mapped to 0 to -2PI
    setNeedle('needle_SPD', -(speed / 80) * Math.PI * 2);
    // Alt: 0-1000m mapped to 0 to -2PI
    setNeedle('needle_ALT', -(alt / 1000) * Math.PI * 2);
    // Heading: 0-360 mapped to 0 to -2PI
    setNeedle('needle_HDG', -(hdg / 360) * Math.PI * 2);
    // VSI: vertical speed
    const vsi = physics.speed * Math.sin(physics.getPitch());
    setNeedle('needle_VSI', -(vsi / 20) * Math.PI);
    setNeedle('needle_TURN', -physics.getRoll());
    setNeedle('needle_RPM', -(physics.throttle || 0) * Math.PI * 1.5);
    setNeedle('needle_VARIO', -(vsi / 15) * Math.PI);
  }
  build(index) {
    if (this.currentAircraft === index) return;
    this.currentAircraft = index;
    while (this.group.children.length) this.group.remove(this.group.children[0]);
    const mat = (color, opts = {}) => new THREE.MeshStandardMaterial({ color, roughness: 0.7, ...opts });
    switch (index) {
      case 0: this.buildBiplane(mat); break;
      case 1: this.buildCessna(mat); break;
      case 2: this.buildGlider(mat); break;
      case 3: this.buildParaglider(mat); break;
      case 4: this.buildHangGlider(mat); break;
      case 5: this.buildF117(mat); break;
      case 6: this.buildF14(mat); break;
    }
  }
  add(mesh) { this.group.add(mesh); }
  makeNeedle(length, color) {
    const geo = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, length, 0)
    ]);
    return new THREE.Line(geo, new THREE.LineBasicMaterial({ color }));
  }
  buildBiplane(mat) {
    const wood = mat(0xaa1111);
    const darkWood = mat(0x881111);
    const metal = mat(0x888888, { metalness: 0.6 });
    const leather = mat(0x553311);
    const darkMetal = mat(0x333333, { metalness: 0.7 });
    const glass = mat(0xaaddff, { transparent: true, opacity: 0.2, metalness: 0 });
    const wire = new THREE.LineBasicMaterial({ color: 0x666666 });
    // Fuselage side panels (low, peripheral)
    for (let s = -1; s <= 1; s += 2) {
      const outer = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.4, 1.4), wood);
      outer.position.set(s * 0.6, -0.5, -0.2);
      this.add(outer);
      // Cockpit rail/coaming
      const rail = new THREE.Mesh(new THREE.BoxGeometry(0.07, 0.04, 1.2), leather);
      rail.position.set(s * 0.58, -0.3, -0.2);
      this.add(rail);
    }
    // Floor
    const floor = new THREE.Mesh(new THREE.BoxGeometry(1.1, 0.04, 1.3), darkWood);
    floor.position.set(0, -0.72, -0.2);
    this.add(floor);
    // Firewall (low, behind dash)
    const firewall = new THREE.Mesh(new THREE.BoxGeometry(1.1, 0.35, 0.04), metal);
    firewall.position.set(0, -0.52, -1.0);
    this.add(firewall);
    // Dashboard panel — LOW, bottom 25% of view
    const dash = new THREE.Mesh(new THREE.BoxGeometry(0.95, 0.28, 0.05), darkWood);
    dash.position.set(0, -0.52, -0.95);
    this.add(dash);
    // Dashboard top pad
    const dashPad = new THREE.Mesh(new THREE.BoxGeometry(0.98, 0.03, 0.1), leather);
    dashPad.position.set(0, -0.37, -0.93);
    this.add(dashPad);
    // Cowling — low profile, pushed down
    const cowlTop = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.05, 0.2), metal);
    cowlTop.position.set(0, -0.28, -1.1);
    this.add(cowlTop);
    // Exhaust pipes (low, below cowl)
    for (let s = -1; s <= 1; s += 2) {
      const pipe = new THREE.Mesh(new THREE.CylinderGeometry(0.018, 0.015, 0.3, 6), darkMetal);
      pipe.position.set(s * 0.28, -0.5, -1.1);
      pipe.rotation.x = Math.PI / 2;
      this.add(pipe);
    }
    // Windscreen (small, biplane-style — open cockpit above)
    const screen = new THREE.Mesh(new THREE.PlaneGeometry(0.7, 0.25), glass);
    screen.position.set(0, -0.22, -0.92);
    screen.rotation.x = -0.3;
    this.add(screen);
    const screenFrame = mat(0x555555, { metalness: 0.3 });
    const scrTop = new THREE.Mesh(new THREE.BoxGeometry(0.72, 0.015, 0.015), screenFrame);
    scrTop.position.set(0, -0.1, -0.9);
    this.add(scrTop);
    // Gun sight ring (WWI style — thin torus in front of windscreen)
    const sightRing = new THREE.Mesh(
      new THREE.TorusGeometry(0.08, 0.003, 8, 24),
      mat(0xbbbbbb, { metalness: 0.6 })
    );
    sightRing.position.set(0, -0.05, -0.95);
    this.add(sightRing);
    // Gun sight crosshairs
    for (let a = 0; a < 4; a++) {
      const cross = new THREE.Mesh(new THREE.BoxGeometry(a % 2 === 0 ? 0.002 : 0.16, a % 2 === 0 ? 0.16 : 0.002, 0.002), mat(0xbbbbbb, { metalness: 0.6 }));
      cross.position.set(0, -0.05, -0.95);
      this.add(cross);
    }
    // Upper wing (high overhead, thin)
    const wing = new THREE.Mesh(new THREE.BoxGeometry(3.5, 0.04, 0.6), wood);
    wing.position.set(0, 0.9, -0.3);
    this.add(wing);
    // Cabane struts (thin, to upper wing)
    for (let s = -1; s <= 1; s += 2) {
      const cabane = new THREE.Mesh(new THREE.CylinderGeometry(0.015, 0.015, 1.0, 4), metal);
      cabane.position.set(s * 0.3, 0.4, -0.4);
      cabane.rotation.z = s * 0.15;
      this.add(cabane);
      // Outer struts
      const strut = new THREE.Mesh(new THREE.CylinderGeometry(0.015, 0.015, 1.1, 4), metal);
      strut.position.set(s * 0.8, 0.3, -0.45);
      this.add(strut);
      // Cross wires
      const w1 = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(s*0.75, -0.3, -0.55), new THREE.Vector3(s*0.75, 0.85, -0.05)
      ]);
      this.add(new THREE.Line(w1, wire));
    }
    // Instruments — tucked into low dash
    const instLabels = ['SPD', 'ALT', 'HDG'];
    for (let i = 0; i < 3; i++) {
      const x = -0.2 + i * 0.2;
      const y = -0.47;
      const inst = new THREE.Mesh(new THREE.CircleGeometry(0.055, 20), mat(0x111111));
      inst.position.set(x, y, -0.92);
      this.add(inst);
      const rim = new THREE.Mesh(new THREE.RingGeometry(0.05, 0.058, 20), mat(0xaa8844, { metalness: 0.5 }));
      rim.position.set(x, y, -0.918);
      this.add(rim);
      for (let t = 0; t < 10; t++) {
        const a = (t / 10) * Math.PI * 2;
        const tick = new THREE.Mesh(new THREE.BoxGeometry(0.002, 0.008, 0.001), mat(0xffffff));
        tick.position.set(x + Math.cos(a)*0.042, y + Math.sin(a)*0.042, -0.917);
        this.add(tick);
      }
      const needle = this.makeNeedle(0.048, 0xff4400);
      needle.position.set(x, y, -0.916);
      needle.name = 'needle_' + instLabels[i];
      this.add(needle);
    }
    // Throttle quadrant (left side, low)
    const throttleBase = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.1, 0.05), darkMetal);
    throttleBase.position.set(-0.5, -0.55, -0.7);
    this.add(throttleBase);
    const throttleKnob = new THREE.Mesh(new THREE.SphereGeometry(0.015, 6, 4), mat(0x222222));
    throttleKnob.position.set(-0.5, -0.48, -0.7);
    this.add(throttleKnob);
    // Stick (center, low)
    const stick = new THREE.Mesh(new THREE.CylinderGeometry(0.012, 0.012, 0.35, 6), metal);
    stick.position.set(0, -0.55, -0.5);
    stick.rotation.x = 0.1;
    this.add(stick);
    const stickGrip = new THREE.Mesh(new THREE.SphereGeometry(0.022, 6, 4), leather);
    stickGrip.position.set(0, -0.38, -0.53);
    this.add(stickGrip);
    // Rudder pedals
    for (let s = -1; s <= 1; s += 2) {
      const pedal = new THREE.Mesh(new THREE.BoxGeometry(0.07, 0.025, 0.1), metal);
      pedal.position.set(s * 0.15, -0.7, -0.75);
      pedal.rotation.x = 0.3;
      this.add(pedal);
    }
    // Propeller blur disc (pushed down to match low cowl)
    const propDisc = new THREE.Mesh(
      new THREE.CircleGeometry(0.3, 20),
      mat(0xaaaaaa, { transparent: true, opacity: 0.1 })
    );
    propDisc.position.set(0, -0.2, -1.2);
    propDisc.name = 'propBlur';
    this.add(propDisc);
    // Leather seat (low)
    const seatBase = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.05, 0.35), leather);
    seatBase.position.set(0, -0.68, 0.1);
    this.add(seatBase);
  }
  buildCessna(mat) {
    const gray = mat(0x555555);
    const dark = mat(0x222222);
    const darkPanel = mat(0x1a1a1a);
    const cream = mat(0xd4c9a8);
    const frameMat = mat(0x333333);
    const metal = mat(0x888888, { metalness: 0.5 });
    const glass = mat(0xaaddff, { transparent: true, opacity: 0.15, metalness: 0 });
    // Cabin walls (low profile, peripheral only)
    for (let s = -1; s <= 1; s += 2) {
      const wall = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.5, 1.6), cream);
      wall.position.set(s * 0.85, -0.35, -0.3);
      this.add(wall);
      // Armrest
      const armrest = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.03, 0.25), mat(0x444444));
      armrest.position.set(s * 0.78, -0.45, -0.1);
      this.add(armrest);
    }
    // Floor
    const floor = new THREE.Mesh(new THREE.BoxGeometry(1.6, 0.03, 1.5), mat(0x444444));
    floor.position.set(0, -0.72, -0.2);
    this.add(floor);
    // Main dashboard panel — LOW, only bottom 25% of view
    const dashBack = new THREE.Mesh(new THREE.BoxGeometry(1.6, 0.35, 0.08), dark);
    dashBack.position.set(0, -0.55, -1.1);
    this.add(dashBack);
    const dashTop = new THREE.Mesh(new THREE.BoxGeometry(1.6, 0.03, 0.12), mat(0x333333));
    dashTop.position.set(0, -0.37, -1.06);
    this.add(dashTop);
    // Glareshield (anti-glare strip on top of dash)
    const glareshield = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.015, 0.08), mat(0x111111));
    glareshield.position.set(0, -0.35, -1.04);
    this.add(glareshield);
    // Compass ball (mounted on top of dash — classic Cessna wet compass)
    const compassBase = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.04, 0.06), mat(0x222222));
    compassBase.position.set(0, -0.33, -1.05);
    this.add(compassBase);
    const compassBall = new THREE.Mesh(
      new THREE.SphereGeometry(0.03, 10, 8),
      mat(0xeeeedd, { metalness: 0.2 })
    );
    compassBall.position.set(0, -0.3, -1.05);
    this.add(compassBall);
    const compassRim = new THREE.Mesh(
      new THREE.RingGeometry(0.025, 0.032, 12),
      mat(0xaaaaaa, { metalness: 0.5 })
    );
    compassRim.position.set(0, -0.3, -1.02);
    this.add(compassRim);
    // Trim indicator (right of center, on dash face)
    const trimBase = new THREE.Mesh(new THREE.BoxGeometry(0.025, 0.08, 0.01), mat(0x0a0a0a));
    trimBase.position.set(0.45, -0.52, -1.055);
    this.add(trimBase);
    const trimPointer = new THREE.Mesh(new THREE.BoxGeometry(0.018, 0.006, 0.005), mat(0x00ff44));
    trimPointer.position.set(0.45, -0.52, -1.05);
    this.add(trimPointer);
    // Six-pack instruments — compact, tucked into lower dash
    const instNames = [['SPD','ALT','HDG'],['VSI','TURN','RPM']];
    for (let r = 0; r < 2; r++) {
      for (let c = 0; c < 3; c++) {
        const x = -0.2 + c * 0.2;
        const y = -0.48 + r * 0.15;
        const inst = new THREE.Mesh(new THREE.CircleGeometry(0.06, 20), mat(0x0a0a0a));
        inst.position.set(x, y, -1.055);
        this.add(inst);
        const rim = new THREE.Mesh(new THREE.RingGeometry(0.055, 0.064, 20), mat(0xaaaaaa, { metalness: 0.7 }));
        rim.position.set(x, y, -1.053);
        this.add(rim);
        // Green arc for ASI
        if (r === 0 && c === 0) {
          for (let a = -2.5; a < -0.5; a += 0.15) {
            const mk = new THREE.Mesh(new THREE.BoxGeometry(0.003, 0.006, 0.001), mat(0x00cc00));
            mk.position.set(x + Math.cos(a)*0.044, y + Math.sin(a)*0.044, -1.052);
            this.add(mk);
          }
        }
        for (let t = 0; t < 12; t++) {
          const angle = (t / 12) * Math.PI * 2;
          const isMajor = t % 3 === 0;
          const tick = new THREE.Mesh(
            new THREE.BoxGeometry(0.002, isMajor ? 0.01 : 0.006, 0.001),
            mat(0xffffff)
          );
          const rad = isMajor ? 0.046 : 0.048;
          tick.position.set(x + Math.cos(angle)*rad, y + Math.sin(angle)*rad, -1.052);
          tick.rotation.z = angle;
          this.add(tick);
        }
        const pivot = new THREE.Mesh(new THREE.CircleGeometry(0.005, 8), mat(0xffffff));
        pivot.position.set(x, y, -1.051);
        this.add(pivot);
        const needle = this.makeNeedle(0.048, 0xff4400);
        needle.position.set(x, y, -1.05);
        needle.name = 'needle_' + instNames[r][c];
        this.add(needle);
      }
    }
    // Avionics stack (center, below six-pack — mostly hidden below view)
    const avStack = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.15, 0.04), darkPanel);
    avStack.position.set(0, -0.65, -1.06);
    this.add(avStack);
    // GPS display
    const gpsBox = new THREE.Mesh(new THREE.BoxGeometry(0.24, 0.05, 0.01), mat(0x0a0a0a));
    gpsBox.position.set(0, -0.62, -1.04);
    this.add(gpsBox);
    const gpsScreen = new THREE.Mesh(new THREE.PlaneGeometry(0.2, 0.035), mat(0x002211, { emissive: 0x001808, emissiveIntensity: 0.3 }));
    gpsScreen.position.set(0, -0.62, -1.035);
    this.add(gpsScreen);
    // Radio stack (right side of dash)
    const radioStack = new THREE.Mesh(new THREE.BoxGeometry(0.18, 0.25, 0.04), darkPanel);
    radioStack.position.set(0.52, -0.48, -1.06);
    this.add(radioStack);
    for (let i = 0; i < 3; i++) {
      const radioLine = new THREE.Mesh(new THREE.BoxGeometry(0.14, 0.003, 0.001), mat(0x00ff44));
      radioLine.position.set(0.52, -0.4 - i * 0.06, -1.04);
      this.add(radioLine);
    }
    // Throttle/Mixture/Prop quadrant (center console, low)
    const quadrant = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.05, 0.18), mat(0x1a1a1a));
    quadrant.position.set(0.32, -0.68, -0.8);
    this.add(quadrant);
    const leverColors = [0x111111, 0xff2222, 0x2266ff];
    for (let i = 0; i < 3; i++) {
      const lever = new THREE.Mesh(new THREE.BoxGeometry(0.012, 0.08, 0.012), mat(leverColors[i]));
      lever.position.set(0.29 + i * 0.025, -0.62, -0.82);
      this.add(lever);
      const knob = new THREE.Mesh(new THREE.SphereGeometry(0.01, 6, 4), mat(leverColors[i]));
      knob.position.set(0.29 + i * 0.025, -0.58, -0.82);
      this.add(knob);
    }
    // Circuit breaker panel (far left, mostly peripheral)
    const cbPanel = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.15, 0.02), darkPanel);
    cbPanel.position.set(-0.68, -0.5, -1.06);
    this.add(cbPanel);
    // Windshield frame — thin, unobtrusive
    const top = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.025, 0.025), frameMat);
    top.position.set(0, 0.65, -1.1);
    this.add(top);
    for (let s = -1; s <= 1; s += 2) {
      const side = new THREE.Mesh(new THREE.BoxGeometry(0.025, 1.1, 0.025), frameMat);
      side.position.set(s * 0.9, 0.1, -1.1);
      side.rotation.z = s * 0.08;
      this.add(side);
    }
    const center = new THREE.Mesh(new THREE.BoxGeometry(0.02, 1.0, 0.02), frameMat);
    center.position.set(0, 0.15, -1.12);
    this.add(center);
    // Glass panels (front + side windows)
    for (let s = -1; s <= 1; s += 2) {
      const pane = new THREE.Mesh(new THREE.PlaneGeometry(0.88, 0.95), glass);
      pane.position.set(s * 0.45, 0.2, -1.1);
      pane.rotation.x = -0.05;
      this.add(pane);
      const sideWin = new THREE.Mesh(new THREE.PlaneGeometry(0.5, 0.45), glass);
      sideWin.position.set(s * 0.9, 0.0, -0.5);
      sideWin.rotation.y = s * -Math.PI / 2.5;
      this.add(sideWin);
    }
    // Yoke column (lower)
    const yokeCol = new THREE.Mesh(new THREE.CylinderGeometry(0.012, 0.012, 0.25, 6), gray);
    yokeCol.position.set(0, -0.52, -0.85);
    yokeCol.rotation.x = Math.PI / 6;
    this.add(yokeCol);
    // Yoke wheel
    const yokeWheel = new THREE.Mesh(new THREE.TorusGeometry(0.07, 0.01, 8, 16), gray);
    yokeWheel.position.set(0, -0.6, -0.75);
    this.add(yokeWheel);
    for (let s = -1; s <= 1; s += 2) {
      const horn = new THREE.Mesh(new THREE.CylinderGeometry(0.008, 0.008, 0.05, 4), gray);
      horn.position.set(s * 0.05, -0.55, -0.75);
      this.add(horn);
    }
    // Rudder pedals (low, far forward)
    for (let s = -1; s <= 1; s += 2) {
      const pedal = new THREE.Mesh(new THREE.BoxGeometry(0.09, 0.035, 0.12), metal);
      pedal.position.set(s * 0.15, -0.7, -0.9);
      pedal.rotation.x = 0.25;
      this.add(pedal);
    }
    // Pilot seat (low, behind)
    const seatBase = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.05, 0.45), mat(0x444444));
    seatBase.position.set(0, -0.68, 0.05);
    this.add(seatBase);
    const seatCushion = new THREE.Mesh(new THREE.BoxGeometry(0.44, 0.06, 0.38), mat(0x555566));
    seatCushion.position.set(0, -0.65, 0.05);
    this.add(seatCushion);
  }
  buildGlider(mat) {
    const frame = mat(0x444444);
    const white = mat(0xeeeeee);
    const darkPanel = mat(0x1a1a1a);
    const metal = mat(0x888888, { metalness: 0.5 });
    const glass = mat(0xaaddff, { transparent: true, opacity: 0.1, metalness: 0, side: THREE.DoubleSide });
    // Fuselage walls (low, narrow)
    for (let s = -1; s <= 1; s += 2) {
      const wall = new THREE.Mesh(new THREE.BoxGeometry(0.03, 0.3, 1.2), white);
      wall.position.set(s * 0.45, -0.5, -0.2);
      this.add(wall);
      const rail = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.02, 1.0), frame);
      rail.position.set(s * 0.44, -0.35, -0.2);
      this.add(rail);
    }
    // Floor
    const floor = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.03, 1.1), mat(0x333333));
    floor.position.set(0, -0.68, -0.2);
    this.add(floor);
    // Bubble canopy (huge, great visibility)
    const canopy = new THREE.Mesh(new THREE.SphereGeometry(1.1, 20, 14, 0, Math.PI * 2, 0, Math.PI * 0.45), glass);
    canopy.position.set(0, 0.0, -0.2);
    this.add(canopy);
    // Canopy frame arcs (thin)
    for (let angle = -0.5; angle <= 0.5; angle += 0.5) {
      const arc = new THREE.Mesh(new THREE.TorusGeometry(1.08, 0.008, 4, 20, Math.PI), frame);
      arc.position.set(0, 0.0, -0.2);
      arc.rotation.y = angle;
      this.add(arc);
    }
    // String yaw indicators on canopy
    const stringGeo = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0.1, 0)
    ]);
    const yawString = new THREE.Line(stringGeo, new THREE.LineBasicMaterial({ color: 0xff0000 }));
    yawString.position.set(0, 0.55, -0.85);
    yawString.name = 'yawString';
    this.add(yawString);
    const yawStr2 = new THREE.Line(stringGeo.clone(), new THREE.LineBasicMaterial({ color: 0x00cc00 }));
    yawStr2.position.set(0.02, 0.55, -0.85);
    this.add(yawStr2);
    // Instrument panel — very LOW, compact
    const dash = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.18, 0.04), darkPanel);
    dash.position.set(0, -0.55, -0.82);
    this.add(dash);
    // Four instruments: Vario, ASI, Altimeter, Compass
    const instNames = ['VARIO', 'SPD', 'ALT', 'HDG'];
    const instX = [-0.18, -0.06, 0.06, 0.18];
    for (let i = 0; i < 4; i++) {
      const r = 0.042;
      const y = -0.53;
      const inst = new THREE.Mesh(new THREE.CircleGeometry(r, 16), mat(0x0a0a0a));
      inst.position.set(instX[i], y, -0.798);
      this.add(inst);
      const rim = new THREE.Mesh(new THREE.RingGeometry(r - 0.004, r + 0.004, 16), metal);
      rim.position.set(instX[i], y, -0.796);
      this.add(rim);
      for (let t = 0; t < 8; t++) {
        const a = (t / 8) * Math.PI * 2;
        const tick = new THREE.Mesh(new THREE.BoxGeometry(0.002, 0.006, 0.001), mat(0xffffff));
        tick.position.set(instX[i] + Math.cos(a)*0.033, y + Math.sin(a)*0.033, -0.795);
        this.add(tick);
      }
      const needle = this.makeNeedle(0.034, i === 0 ? 0x00ff00 : 0xff4400);
      needle.position.set(instX[i], y, -0.794);
      needle.name = 'needle_' + instNames[i];
      this.add(needle);
    }
    // MacCready ring
    const mcRing = new THREE.Mesh(new THREE.RingGeometry(0.044, 0.048, 16, 1, 0, Math.PI * 1.5), mat(0xffcc00));
    mcRing.position.set(instX[0], -0.53, -0.797);
    this.add(mcRing);
    // Flap lever (left side, low)
    const flapLever = new THREE.Mesh(new THREE.CylinderGeometry(0.007, 0.007, 0.1, 4), metal);
    flapLever.position.set(-0.32, -0.55, -0.6);
    this.add(flapLever);
    const flapKnob = new THREE.Mesh(new THREE.SphereGeometry(0.012, 6, 4), mat(0x2266ff));
    flapKnob.position.set(-0.32, -0.5, -0.6);
    this.add(flapKnob);
    // Tow release handle (yellow)
    const releaseHandle = new THREE.Mesh(new THREE.SphereGeometry(0.015, 6, 4), mat(0xffcc00));
    releaseHandle.position.set(-0.15, -0.6, -0.65);
    this.add(releaseHandle);
    // Stick (center, low)
    const stick = new THREE.Mesh(new THREE.CylinderGeometry(0.009, 0.009, 0.3, 6), frame);
    stick.position.set(0, -0.55, -0.5);
    stick.rotation.x = 0.12;
    this.add(stick);
    const stickGrip = new THREE.Mesh(new THREE.SphereGeometry(0.018, 6, 4), mat(0x333333));
    stickGrip.position.set(0, -0.4, -0.53);
    this.add(stickGrip);
    // Rudder pedals
    for (let s = -1; s <= 1; s += 2) {
      const pedal = new THREE.Mesh(new THREE.BoxGeometry(0.07, 0.025, 0.09), metal);
      pedal.position.set(s * 0.12, -0.66, -0.75);
      pedal.rotation.x = 0.2;
      this.add(pedal);
    }
    // Seat (low, reclined)
    const seatBase = new THREE.Mesh(new THREE.BoxGeometry(0.38, 0.04, 0.45), mat(0x444466));
    seatBase.position.set(0, -0.66, 0.05);
    seatBase.rotation.x = -0.1;
    this.add(seatBase);
    // Nose cone (LOW, below view center)
    const noseCone = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.2, 0.35, 8), white);
    noseCone.position.set(0, -0.48, -1.1);
    noseCone.rotation.x = Math.PI / 2;
    this.add(noseCone);
  }
  buildParaglider(mat) {
    const fabric = mat(0xff6600, { side: THREE.DoubleSide });
    const accentFabric = mat(0xffcc00, { side: THREE.DoubleSide });
    const line = new THREE.LineBasicMaterial({ color: 0x444444 });
    const thinLine = new THREE.LineBasicMaterial({ color: 0x666666, transparent: true, opacity: 0.6 });
    const skin = mat(0xddaa88);
    const harnessMat = mat(0x333333);
    // Canopy — multi-cell with color panels
    for (let cell = -5; cell <= 5; cell++) {
      const cellGeo = new THREE.SphereGeometry(0.4, 8, 4, 0, Math.PI * 2, 0.2, 0.5);
      cellGeo.scale(1, 0.12, 0.35);
      const useFab = Math.abs(cell) % 2 === 0 ? fabric : accentFabric;
      const cellMesh = new THREE.Mesh(cellGeo, useFab);
      cellMesh.position.set(cell * 0.28, 3.5, -0.5);
      this.add(cellMesh);
    }
    // Canopy leading edge (slightly darker ridge)
    const leadEdge = new THREE.Mesh(new THREE.BoxGeometry(3.2, 0.02, 0.03), mat(0xcc5500, { side: THREE.DoubleSide }));
    leadEdge.position.set(0, 3.55, -0.65);
    this.add(leadEdge);
    // A-lines (front row), B-lines (back row), C-lines
    for (let row = 0; row < 3; row++) {
      const zOff = -0.6 + row * 0.12;
      const lineMat = row === 0 ? line : thinLine;
      for (let i = -4; i <= 4; i++) {
        const pts = [
          new THREE.Vector3(i * 0.32, 3.1 + row * 0.05, zOff),
          new THREE.Vector3(i * 0.04, 0.25, -0.25 + row * 0.05)
        ];
        this.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), lineMat));
      }
    }
    // Risers (thick straps from carabiners to lines)
    for (let s = -1; s <= 1; s += 2) {
      const riser = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.5, 0.01), mat(0x555555));
      riser.position.set(s * 0.2, 0.45, -0.3);
      this.add(riser);
      // Carabiner
      const carabiner = new THREE.Mesh(new THREE.TorusGeometry(0.015, 0.004, 4, 8), mat(0xcccccc, { metalness: 0.7 }));
      carabiner.position.set(s * 0.2, 0.2, -0.3);
      this.add(carabiner);
    }
    // Harness (pod-style, more realistic)
    const harnessShell = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.18, 0.5, 8), harnessMat);
    harnessShell.position.set(0, -0.25, -0.15);
    harnessShell.rotation.x = 0.1;
    this.add(harnessShell);
    // Harness seatboard
    const seatboard = new THREE.Mesh(new THREE.BoxGeometry(0.38, 0.03, 0.35), mat(0x444444));
    seatboard.position.set(0, -0.35, -0.1);
    this.add(seatboard);
    // Shoulder straps
    for (let s = -1; s <= 1; s += 2) {
      const strap = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.55, 0.015), mat(0x444444));
      strap.position.set(s * 0.15, 0.02, -0.18);
      strap.rotation.z = s * 0.08;
      this.add(strap);
    }
    // Chest strap buckle
    const chestBuckle = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.03, 0.015), mat(0xaaaaaa, { metalness: 0.6 }));
    chestBuckle.position.set(0, 0.1, -0.22);
    this.add(chestBuckle);
    // Reserve parachute handle (red, right side)
    const reserveHandle = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.04, 0.03), mat(0xff0000));
    reserveHandle.position.set(0.25, -0.15, -0.08);
    this.add(reserveHandle);
    // Cockpit instrument pod (small flight deck)
    const instPod = new THREE.Mesh(new THREE.BoxGeometry(0.18, 0.12, 0.04), mat(0x222222));
    instPod.position.set(0, -0.05, -0.38);
    instPod.rotation.x = -0.3;
    this.add(instPod);
    // Vario screen on pod
    const varioScreen = new THREE.Mesh(new THREE.PlaneGeometry(0.14, 0.08), mat(0x001100, { emissive: 0x001808, emissiveIntensity: 0.3 }));
    varioScreen.position.set(0, -0.04, -0.36);
    varioScreen.rotation.x = -0.3;
    this.add(varioScreen);
    // Speed bar system (foot accelerator)
    for (let s = -1; s <= 1; s += 2) {
      const barLine = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(s * 0.15, 0.2, -0.28),
        new THREE.Vector3(s * 0.08, -0.8, -0.35)
      ]);
      this.add(new THREE.Line(barLine, line));
    }
    const speedBar = new THREE.Mesh(new THREE.CylinderGeometry(0.008, 0.008, 0.2, 4), mat(0x555555));
    speedBar.position.set(0, -0.8, -0.35);
    speedBar.rotation.z = Math.PI / 2;
    this.add(speedBar);
    // Visible legs (dangling)
    for (let s = -1; s <= 1; s += 2) {
      const thigh = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.038, 0.4, 5), mat(0x333355));
      thigh.position.set(s * 0.12, -0.55, -0.05);
      thigh.rotation.x = 0.25;
      this.add(thigh);
      const shin = new THREE.Mesh(new THREE.CylinderGeometry(0.035, 0.03, 0.4, 5), mat(0x333355));
      shin.position.set(s * 0.12, -0.85, -0.18);
      shin.rotation.x = 0.4;
      this.add(shin);
      const boot = new THREE.Mesh(new THREE.BoxGeometry(0.065, 0.04, 0.12), mat(0x222222));
      boot.position.set(s * 0.12, -1.05, -0.3);
      this.add(boot);
    }
    // Hands with brake toggles
    for (let s = -1; s <= 1; s += 2) {
      // Forearm
      const arm = new THREE.Mesh(new THREE.CylinderGeometry(0.025, 0.022, 0.25, 5), skin);
      arm.position.set(s * 0.28, 0.05, -0.15);
      arm.rotation.z = s * 0.6;
      arm.rotation.x = -0.2;
      this.add(arm);
      // Hand (fist around toggle)
      const hand = new THREE.Mesh(new THREE.SphereGeometry(0.035, 6, 4), skin);
      hand.position.set(s * 0.38, 0.0, -0.12);
      this.add(hand);
      // Brake toggle (loop)
      const toggle = new THREE.Mesh(new THREE.TorusGeometry(0.02, 0.004, 4, 8), mat(0x222222));
      toggle.position.set(s * 0.38, -0.03, -0.12);
      this.add(toggle);
      // Brake line from toggle up to canopy trailing edge
      const brakeLine = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(s * 0.38, 0.0, -0.12),
        new THREE.Vector3(s * 2.2, 3.15, -0.35)
      ]);
      this.add(new THREE.Line(brakeLine, line));
    }
    // Helmet (visible at top of view)
    const helmet = new THREE.Mesh(new THREE.SphereGeometry(0.14, 8, 6, 0, Math.PI * 2, 0, Math.PI * 0.6), mat(0xeeeeee));
    helmet.position.set(0, 0.45, 0.05);
    this.add(helmet);
  }
  buildHangGlider(mat) {
    const tube = mat(0x888888, { metalness: 0.5 });
    const darkTube = mat(0x555555, { metalness: 0.4 });
    const fabric = mat(0x2266cc, { side: THREE.DoubleSide });
    const skin = mat(0xddaa88);
    const harnessMat = mat(0x333333);
    const wire = new THREE.LineBasicMaterial({ color: 0x999999 });
    // Control bar (A-frame base bar)
    const bar = new THREE.Mesh(new THREE.CylinderGeometry(0.022, 0.022, 1.5, 8), tube);
    bar.position.set(0, -0.3, -0.5);
    bar.rotation.z = Math.PI / 2;
    this.add(bar);
    // Bar padding (foam grips)
    for (let s = -1; s <= 1; s += 2) {
      const grip = new THREE.Mesh(new THREE.CylinderGeometry(0.028, 0.028, 0.2, 8), mat(0x222222));
      grip.position.set(s * 0.25, -0.3, -0.5);
      grip.rotation.z = Math.PI / 2;
      this.add(grip);
    }
    // Uprights (A-frame sides) with kingpost
    for (let s = -1; s <= 1; s += 2) {
      const upright = new THREE.Mesh(new THREE.CylinderGeometry(0.018, 0.018, 1.9, 6), tube);
      upright.position.set(s * 0.48, 0.55, -0.5);
      upright.rotation.z = s * 0.26;
      this.add(upright);
      // Base corner brackets
      const bracket = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.04, 0.04), darkTube);
      bracket.position.set(s * 0.7, -0.3, -0.5);
      this.add(bracket);
    }
    // Kingpost (above keel, extends up)
    const kingpost = new THREE.Mesh(new THREE.CylinderGeometry(0.012, 0.012, 0.6, 4), tube);
    kingpost.position.set(0, 1.9, -0.55);
    this.add(kingpost);
    // Keel tube (center front bar)
    const keel = new THREE.Mesh(new THREE.CylinderGeometry(0.018, 0.018, 2.8, 6), tube);
    keel.position.set(0, 1.2, -0.8);
    keel.rotation.x = 0.28;
    this.add(keel);
    // Cross tube (horizontal, connects leading edges)
    const crossTube = new THREE.Mesh(new THREE.CylinderGeometry(0.014, 0.014, 3.2, 6), tube);
    crossTube.position.set(0, 1.35, -0.9);
    crossTube.rotation.z = Math.PI / 2;
    this.add(crossTube);
    // Luff lines (from kingpost to leading edge - tension wires)
    for (let s = -1; s <= 1; s += 2) {
      const ll = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, 2.2, -0.55),
        new THREE.Vector3(s * 1.8, 1.3, -1.2)
      ]);
      this.add(new THREE.Line(ll, wire));
      // Lower rigging
      const lr = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(s * 0.7, -0.3, -0.5),
        new THREE.Vector3(s * 1.8, 1.3, -1.2)
      ]);
      this.add(new THREE.Line(lr, wire));
    }
    // Side flying wires
    for (let s = -1; s <= 1; s += 2) {
      const sw = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, 1.45, -0.5),
        new THREE.Vector3(s * 2.5, 1.2, -1.5)
      ]);
      this.add(new THREE.Line(sw, wire));
    }
    // Delta wing sail
    const wingShape = new THREE.Shape();
    wingShape.moveTo(0, 0);
    wingShape.lineTo(-3.8, -2.2);
    wingShape.lineTo(3.8, -2.2);
    wingShape.closePath();
    const wingGeo = new THREE.ShapeGeometry(wingShape);
    wingGeo.rotateX(-Math.PI / 2);
    const wing = new THREE.Mesh(wingGeo, fabric);
    wing.position.set(0, 1.5, -0.2);
    this.add(wing);
    // Wing panels (color sections)
    const panel1 = new THREE.Shape();
    panel1.moveTo(-0.3, 0);
    panel1.lineTo(-1.5, -1.8);
    panel1.lineTo(1.5, -1.8);
    panel1.lineTo(0.3, 0);
    panel1.closePath();
    const panelGeo = new THREE.ShapeGeometry(panel1);
    panelGeo.rotateX(-Math.PI / 2);
    const panelMesh = new THREE.Mesh(panelGeo, mat(0xffffff, { side: THREE.DoubleSide }));
    panelMesh.position.set(0, 1.52, -0.2);
    this.add(panelMesh);
    // Wingtip accent
    for (let s = -1; s <= 1; s += 2) {
      const tipShape = new THREE.Shape();
      tipShape.moveTo(0, 0);
      tipShape.lineTo(s * -0.8, -0.5);
      tipShape.lineTo(s * -0.3, -0.5);
      tipShape.closePath();
      const tipGeo = new THREE.ShapeGeometry(tipShape);
      tipGeo.rotateX(-Math.PI / 2);
      const tip = new THREE.Mesh(tipGeo, mat(0xff4400, { side: THREE.DoubleSide }));
      tip.position.set(s * 3.0, 1.52, -1.6);
      this.add(tip);
    }
    // Battens (stiffening ribs visible through sail)
    for (let i = -3; i <= 3; i++) {
      const batten = new THREE.Mesh(new THREE.CylinderGeometry(0.005, 0.005, 1.8, 3), darkTube);
      batten.position.set(i * 0.5, 1.48, -0.8);
      batten.rotation.z = i * 0.12;
      batten.rotation.x = Math.PI / 2.5;
      this.add(batten);
    }
    // Hands gripping control bar
    for (let s = -1; s <= 1; s += 2) {
      const hand = new THREE.Mesh(new THREE.SphereGeometry(0.035, 6, 4), skin);
      hand.position.set(s * 0.28, -0.28, -0.5);
      this.add(hand);
      // Fingers wrapped
      for (let f = 0; f < 3; f++) {
        const finger = new THREE.Mesh(new THREE.CylinderGeometry(0.006, 0.005, 0.03, 4), skin);
        finger.position.set(s * 0.27 + (f-1) * 0.012, -0.3, -0.5);
        this.add(finger);
      }
      // Forearm
      const arm = new THREE.Mesh(new THREE.CylinderGeometry(0.022, 0.025, 0.28, 5), skin);
      arm.position.set(s * 0.22, -0.18, -0.38);
      arm.rotation.z = s * 0.5;
      arm.rotation.x = -0.2;
      this.add(arm);
    }
    // Pilot body (prone position, hanging below)
    const torso = new THREE.Mesh(new THREE.CylinderGeometry(0.07, 0.06, 0.65, 6), harnessMat);
    torso.rotation.x = Math.PI / 2;
    torso.position.set(0, -0.5, 0.1);
    this.add(torso);
    // Harness pod (cocoon style)
    const harnessPod = new THREE.Mesh(new THREE.CylinderGeometry(0.09, 0.06, 0.8, 6), mat(0x444444));
    harnessPod.rotation.x = Math.PI / 2;
    harnessPod.position.set(0, -0.52, 0.15);
    this.add(harnessPod);
    // Hang loop (connects harness to keel)
    const hangLoop = new THREE.Mesh(new THREE.TorusGeometry(0.02, 0.005, 4, 8), mat(0xbbbbbb, { metalness: 0.6 }));
    hangLoop.position.set(0, -0.35, -0.3);
    this.add(hangLoop);
    // Carabiner
    const carab = new THREE.Mesh(new THREE.TorusGeometry(0.015, 0.004, 4, 6), mat(0xdddddd, { metalness: 0.7 }));
    carab.position.set(0, -0.38, -0.3);
    carab.rotation.x = Math.PI / 2;
    this.add(carab);
    // Legs (together in harness, feet visible at back)
    for (let s = -1; s <= 1; s += 2) {
      const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.035, 0.03, 0.55, 4), mat(0x333355));
      leg.rotation.x = Math.PI / 2;
      leg.position.set(s * 0.06, -0.55, 0.5);
      this.add(leg);
      const boot = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.04, 0.1), mat(0x222222));
      boot.position.set(s * 0.06, -0.56, 0.78);
      this.add(boot);
    }
    // Variometer strapped to upright
    const varioBox = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.06, 0.02), mat(0x111111));
    varioBox.position.set(0.5, 0.4, -0.5);
    this.add(varioBox);
    const varioScreen = new THREE.Mesh(new THREE.PlaneGeometry(0.03, 0.04), mat(0x001100, { emissive: 0x002200, emissiveIntensity: 0.3 }));
    varioScreen.position.set(0.5, 0.4, -0.49);
    this.add(varioScreen);
    // Helmet edge visible at top
    const helmetRim = new THREE.Mesh(new THREE.TorusGeometry(0.13, 0.015, 6, 12, Math.PI), mat(0xeeeeee));
    helmetRim.position.set(0, 0.32, 0.0);
    helmetRim.rotation.x = 0.3;
    this.add(helmetRim);
  }
  buildF117(mat) {
    const dark = mat(0x111111);
    const darkPanel = mat(0x0a0a0a);
    const metal = mat(0x333333, { metalness: 0.6 });
    const greenHUD = mat(0x00ff44, { emissive: 0x00ff44, emissiveIntensity: 0.6, transparent: true, opacity: 0.3 });
    const canopyGlass = mat(0xaa8833, { transparent: true, opacity: 0.08 });
    const hudLine = new THREE.LineBasicMaterial({ color: 0x00ff44, transparent: true, opacity: 0.6 });
    // Angular side panels
    for (let s = -1; s <= 1; s += 2) {
      const panel = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.45, 1.4), dark);
      panel.position.set(s * 0.55, -0.45, -0.2);
      this.add(panel);
      const coaming = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.03, 1.2), metal);
      coaming.position.set(s * 0.54, -0.22, -0.2);
      this.add(coaming);
    }
    // Floor
    const floor = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.03, 1.3), mat(0x0a0a0a));
    floor.position.set(0, -0.7, -0.2);
    this.add(floor);
    // Main instrument panel — angular, dark
    const dash = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.3, 0.06), darkPanel);
    dash.position.set(0, -0.5, -1.0);
    this.add(dash);
    const dashTop = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.03, 0.1), metal);
    dashTop.position.set(0, -0.34, -0.96);
    this.add(dashTop);
    // HUD frame — thin green wireframe
    const hudPts = [
      new THREE.Vector3(-0.2, 0.1, -0.9),
      new THREE.Vector3(0.2, 0.1, -0.9),
      new THREE.Vector3(0.2, -0.15, -0.9),
      new THREE.Vector3(-0.2, -0.15, -0.9),
      new THREE.Vector3(-0.2, 0.1, -0.9)
    ];
    const hudFrame = new THREE.Line(new THREE.BufferGeometry().setFromPoints(hudPts), hudLine);
    this.add(hudFrame);
    // HUD glass combiner
    const hudGlass = new THREE.Mesh(new THREE.PlaneGeometry(0.38, 0.24), greenHUD);
    hudGlass.position.set(0, -0.02, -0.9);
    hudGlass.rotation.x = -0.15;
    this.add(hudGlass);
    // Three instruments: SPD, ALT, HDG
    const instLabels = ['SPD', 'ALT', 'HDG'];
    for (let i = 0; i < 3; i++) {
      const x = -0.22 + i * 0.22;
      const y = -0.47;
      const inst = new THREE.Mesh(new THREE.CircleGeometry(0.055, 20), mat(0x050505));
      inst.position.set(x, y, -0.97);
      this.add(inst);
      const rim = new THREE.Mesh(new THREE.RingGeometry(0.05, 0.058, 20), mat(0x444444, { metalness: 0.5 }));
      rim.position.set(x, y, -0.968);
      this.add(rim);
      for (let t = 0; t < 10; t++) {
        const a = (t / 10) * Math.PI * 2;
        const tick = new THREE.Mesh(new THREE.BoxGeometry(0.002, 0.008, 0.001), mat(0x00ff44));
        tick.position.set(x + Math.cos(a) * 0.042, y + Math.sin(a) * 0.042, -0.967);
        this.add(tick);
      }
      const needle = this.makeNeedle(0.045, 0x00ff44);
      needle.position.set(x, y, -0.966);
      needle.name = 'needle_' + instLabels[i];
      this.add(needle);
    }
    // Side stick (right side, stealth fighters use side stick)
    const stick = new THREE.Mesh(new THREE.CylinderGeometry(0.012, 0.012, 0.25, 6), metal);
    stick.position.set(0.3, -0.55, -0.55);
    stick.rotation.x = 0.1;
    this.add(stick);
    const stickGrip = new THREE.Mesh(new THREE.BoxGeometry(0.03, 0.04, 0.06), mat(0x222222));
    stickGrip.position.set(0.3, -0.43, -0.57);
    this.add(stickGrip);
    // Throttle (left side)
    const throttleBase = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.06, 0.12), metal);
    throttleBase.position.set(-0.4, -0.55, -0.6);
    this.add(throttleBase);
    const throttleLever = new THREE.Mesh(new THREE.CylinderGeometry(0.008, 0.008, 0.15, 5), mat(0x222222));
    throttleLever.position.set(-0.4, -0.48, -0.6);
    this.add(throttleLever);
    // Angular canopy frame (gold-tinted)
    const frameMat = mat(0x444444);
    const topFrame = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.02, 0.02), frameMat);
    topFrame.position.set(0, 0.35, -0.8);
    this.add(topFrame);
    for (let s = -1; s <= 1; s += 2) {
      const sideFrame = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.6, 0.02), frameMat);
      sideFrame.position.set(s * 0.4, 0.05, -0.8);
      sideFrame.rotation.z = s * 0.15;
      this.add(sideFrame);
    }
    // Gold-tinted canopy glass
    const canopy = new THREE.Mesh(new THREE.PlaneGeometry(0.9, 0.7), canopyGlass);
    canopy.position.set(0, 0.1, -0.85);
    canopy.rotation.x = -0.1;
    this.add(canopy);
    // Rudder pedals
    for (let s = -1; s <= 1; s += 2) {
      const pedal = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.025, 0.1), metal);
      pedal.position.set(s * 0.14, -0.68, -0.8);
      pedal.rotation.x = 0.25;
      this.add(pedal);
    }
    // Ejection seat
    const seatBase = new THREE.Mesh(new THREE.BoxGeometry(0.45, 0.05, 0.4), mat(0x222222));
    seatBase.position.set(0, -0.66, 0.05);
    this.add(seatBase);
    const seatBack = new THREE.Mesh(new THREE.BoxGeometry(0.42, 0.5, 0.06), mat(0x1a1a1a));
    seatBack.position.set(0, -0.4, 0.25);
    seatBack.rotation.x = 0.1;
    this.add(seatBack);
    // Ejection handle (yellow/black striped)
    const ejectHandle = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.025, 0.04), mat(0xffcc00));
    ejectHandle.position.set(0, -0.68, -0.15);
    this.add(ejectHandle);
  }
  buildF14(mat) {
    const gray = mat(0x555555);
    const darkPanel = mat(0x111111);
    const metal = mat(0x888888, { metalness: 0.5 });
    const canopyGlass = mat(0xaaddff, { transparent: true, opacity: 0.12 });
    const greenHUD = mat(0x00ff44, { emissive: 0x00ff44, emissiveIntensity: 0.5, transparent: true, opacity: 0.25 });
    const hudLine = new THREE.LineBasicMaterial({ color: 0x00ff44, transparent: true, opacity: 0.6 });
    const greenGlow = mat(0x00ff44, { emissive: 0x00ff44, emissiveIntensity: 0.3 });
    // Cabin walls
    for (let s = -1; s <= 1; s += 2) {
      const wall = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.5, 1.5), gray);
      wall.position.set(s * 0.65, -0.4, -0.2);
      this.add(wall);
      const rail = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.03, 1.3), mat(0x444444));
      rail.position.set(s * 0.63, -0.15, -0.2);
      this.add(rail);
    }
    // Floor
    const floor = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.03, 1.4), mat(0x333333));
    floor.position.set(0, -0.7, -0.2);
    this.add(floor);
    // Main instrument panel
    const dash = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.4, 0.06), darkPanel);
    dash.position.set(0, -0.48, -1.05);
    this.add(dash);
    const dashTop = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.03, 0.1), mat(0x333333));
    dashTop.position.set(0, -0.27, -1.0);
    this.add(dashTop);
    // HUD frame
    const hudPts = [
      new THREE.Vector3(-0.22, 0.12, -0.95),
      new THREE.Vector3(0.22, 0.12, -0.95),
      new THREE.Vector3(0.22, -0.12, -0.95),
      new THREE.Vector3(-0.22, -0.12, -0.95),
      new THREE.Vector3(-0.22, 0.12, -0.95)
    ];
    const hudFrame = new THREE.Line(new THREE.BufferGeometry().setFromPoints(hudPts), hudLine);
    this.add(hudFrame);
    const hudGlass = new THREE.Mesh(new THREE.PlaneGeometry(0.42, 0.22), greenHUD);
    hudGlass.position.set(0, 0.0, -0.95);
    hudGlass.rotation.x = -0.12;
    this.add(hudGlass);
    // Six instruments: SPD, ALT, HDG (top), VSI, TURN, RPM (bottom)
    const instNames = [['SPD','ALT','HDG'],['VSI','TURN','RPM']];
    for (let r = 0; r < 2; r++) {
      for (let c = 0; c < 3; c++) {
        const x = -0.22 + c * 0.22;
        const y = -0.45 + r * 0.17;
        const inst = new THREE.Mesh(new THREE.CircleGeometry(0.058, 20), mat(0x080808));
        inst.position.set(x, y, -1.02);
        this.add(inst);
        const rim = new THREE.Mesh(new THREE.RingGeometry(0.053, 0.061, 20), mat(0x999999, { metalness: 0.6 }));
        rim.position.set(x, y, -1.018);
        this.add(rim);
        for (let t = 0; t < 12; t++) {
          const angle = (t / 12) * Math.PI * 2;
          const tick = new THREE.Mesh(new THREE.BoxGeometry(0.002, t % 3 === 0 ? 0.01 : 0.006, 0.001), mat(0xffffff));
          tick.position.set(x + Math.cos(angle) * 0.046, y + Math.sin(angle) * 0.046, -1.017);
          tick.rotation.z = angle;
          this.add(tick);
        }
        const needle = this.makeNeedle(0.046, 0xff4400);
        needle.position.set(x, y, -1.016);
        needle.name = 'needle_' + instNames[r][c];
        this.add(needle);
      }
    }
    // Mach display (small green-tinted screen right of instruments)
    const machBox = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.06, 0.01), darkPanel);
    machBox.position.set(0.5, -0.38, -1.02);
    this.add(machBox);
    const machScreen = new THREE.Mesh(new THREE.PlaneGeometry(0.08, 0.04), mat(0x001100, { emissive: 0x002200, emissiveIntensity: 0.3 }));
    machScreen.position.set(0.5, -0.38, -1.015);
    this.add(machScreen);
    // Radar scope (small green-tinted circular screen, lower right)
    const radarRim = new THREE.Mesh(new THREE.RingGeometry(0.04, 0.048, 16), mat(0x555555, { metalness: 0.5 }));
    radarRim.position.set(0.5, -0.55, -1.02);
    this.add(radarRim);
    const radarScreen = new THREE.Mesh(new THREE.CircleGeometry(0.04, 16), mat(0x001a00, { emissive: 0x003300, emissiveIntensity: 0.4 }));
    radarScreen.position.set(0.5, -0.55, -1.018);
    this.add(radarScreen);
    // Radar sweep line
    const sweepGeo = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0.035, 0)
    ]);
    const radarSweep = new THREE.Line(sweepGeo, new THREE.LineBasicMaterial({ color: 0x00ff44 }));
    radarSweep.position.set(0.5, -0.55, -1.016);
    this.add(radarSweep);
    // Center stick with grip
    const stick = new THREE.Mesh(new THREE.CylinderGeometry(0.014, 0.014, 0.3, 6), metal);
    stick.position.set(0, -0.52, -0.6);
    stick.rotation.x = 0.1;
    this.add(stick);
    const stickGrip = new THREE.Mesh(new THREE.BoxGeometry(0.035, 0.05, 0.055), mat(0x222222));
    stickGrip.position.set(0, -0.37, -0.63);
    this.add(stickGrip);
    // Trigger on stick
    const trigger = new THREE.Mesh(new THREE.BoxGeometry(0.008, 0.025, 0.015), metal);
    trigger.position.set(0, -0.39, -0.66);
    this.add(trigger);
    // Twin throttle levers (left side)
    const throttleBase = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.04, 0.15), mat(0x1a1a1a));
    throttleBase.position.set(-0.5, -0.58, -0.65);
    this.add(throttleBase);
    for (let i = 0; i < 2; i++) {
      const lever = new THREE.Mesh(new THREE.CylinderGeometry(0.008, 0.008, 0.18, 5), mat(0x333333));
      lever.position.set(-0.48 + i * 0.04, -0.48, -0.65);
      this.add(lever);
      const knob = new THREE.Mesh(new THREE.SphereGeometry(0.014, 6, 4), mat(0x222222));
      knob.position.set(-0.48 + i * 0.04, -0.39, -0.65);
      this.add(knob);
    }
    // Canopy bow frame overhead
    const bowFrame = mat(0x555555);
    const bow = new THREE.Mesh(new THREE.TorusGeometry(0.65, 0.015, 6, 16, Math.PI), bowFrame);
    bow.position.set(0, 0.2, -0.5);
    bow.rotation.x = Math.PI;
    bow.rotation.z = Math.PI;
    this.add(bow);
    // Canopy side frames
    for (let s = -1; s <= 1; s += 2) {
      const sideFrame = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.8, 0.02), bowFrame);
      sideFrame.position.set(s * 0.6, 0.1, -0.6);
      sideFrame.rotation.z = s * 0.12;
      this.add(sideFrame);
    }
    // Glass panels
    for (let s = -1; s <= 1; s += 2) {
      const pane = new THREE.Mesh(new THREE.PlaneGeometry(0.58, 0.8), canopyGlass);
      pane.position.set(s * 0.3, 0.15, -0.98);
      this.add(pane);
    }
    // Rudder pedals
    for (let s = -1; s <= 1; s += 2) {
      const pedal = new THREE.Mesh(new THREE.BoxGeometry(0.09, 0.03, 0.12), metal);
      pedal.position.set(s * 0.15, -0.68, -0.85);
      pedal.rotation.x = 0.25;
      this.add(pedal);
    }
    // Ejection seat
    const seatBase = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.05, 0.42), mat(0x333333));
    seatBase.position.set(0, -0.66, 0.05);
    this.add(seatBase);
    const seatBack = new THREE.Mesh(new THREE.BoxGeometry(0.46, 0.55, 0.06), mat(0x222222));
    seatBack.position.set(0, -0.38, 0.26);
    seatBack.rotation.x = 0.1;
    this.add(seatBack);
    // Ejection handle
    const ejectHandle = new THREE.Mesh(new THREE.BoxGeometry(0.16, 0.025, 0.04), mat(0xffcc00));
    ejectHandle.position.set(0, -0.66, -0.18);
    this.add(ejectHandle);
  }
}

// ─── AircraftModels ───
class AircraftModels {
  constructor(scene) {
    this.scene = scene;
    this.models = {};
    this.currentModel = null;
    this.currentIndex = -1;
    this.buildAllModels();
  }
  buildAllModels() {
    this.models[0] = this.buildBiplane();
    this.models[1] = this.buildCessna();
    this.models[2] = this.buildGlider();
    this.models[3] = this.buildParaglider();
    this.models[4] = this.buildHangGlider();
    this.models[5] = this.buildF117();
    this.models[6] = this.buildF14();
    Object.values(this.models).forEach(m => { m.visible = false; this.scene.add(m); });
  }
  show(index) {
    if (this.currentModel) this.currentModel.visible = false;
    this.currentIndex = index;
    this.currentModel = this.models[index];
    if (this.currentModel) this.currentModel.visible = true;
  }
  hide() {
    if (this.currentModel) this.currentModel.visible = false;
  }
  updateTransform(position, quaternion) {
    if (!this.currentModel || !this.currentModel.visible) return;
    this.currentModel.position.copy(position);
    this.currentModel.quaternion.copy(quaternion);
  }
  updatePropeller(dt) {
    if (!this.currentModel) return;
    const prop = this.currentModel.getObjectByName('propeller');
    if (prop) prop.rotation.z += dt * 40;
  }
  updateAfterburner(dt, throttle, aircraft) {
    if (!this.currentModel) return;
    const abNames = ['afterburner', 'afterburner_L', 'afterburner_R'];
    for (const name of abNames) {
      const ab = this.currentModel.getObjectByName(name);
      if (!ab) continue;
      if (!aircraft.hasAfterburner || throttle < 0.10) {
        ab.visible = false;
        continue;
      }
      ab.visible = true;
      if (throttle > 0.85) {
        // Full afterburner — big flaming effect with flickering
        const pulse = 0.9 + 0.3 * Math.sin(Date.now() * 0.015);
        const flicker = 0.95 + 0.1 * Math.sin(Date.now() * 0.047);
        ab.scale.set(pulse * flicker, pulse * flicker, 1.0 + 0.2 * Math.sin(Date.now() * 0.02));
        ab.material.emissiveIntensity = 2.0 * pulse;
        ab.material.opacity = 0.85;
      } else {
        // Low/mid throttle — small dim exhaust glow
        const t = (throttle - 0.10) / 0.75; // 0 to 1 over 10-85% range
        ab.scale.set(0.3 + t * 0.4, 0.3 + t * 0.4, 0.3 + t * 0.3);
        ab.material.emissiveIntensity = 0.3 + t * 0.7;
        ab.material.opacity = 0.3 + t * 0.3;
      }
    }
  }
  buildBiplane() {
    const group = new THREE.Group();
    const mat = (color, opts={}) => new THREE.MeshStandardMaterial({ color, roughness: 0.7, ...opts });
    const body = mat(0xcc1111);
    const accent = mat(0xdd2222);
    const metal = mat(0x777777, { metalness: 0.6 });
    const dark = mat(0x443322);
    // Fuselage — tapered box shape
    const fuseMain = new THREE.Mesh(new THREE.BoxGeometry(1.4, 1.1, 4), body);
    group.add(fuseMain);
    const fuseTail = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.8, 2.5), body);
    fuseTail.position.set(0, 0.1, 2.5);
    group.add(fuseTail);
    // Engine cowling
    const cowl = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.65, 1.5, 10), metal);
    cowl.rotation.x = Math.PI/2; cowl.position.z = -2.8;
    group.add(cowl);
    // Exhaust pipes
    for (let s = -1; s <= 1; s += 2) {
      const exhaust = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 0.6, 5), mat(0x444444, { metalness: 0.7 }));
      exhaust.rotation.z = Math.PI/2;
      exhaust.position.set(s * 0.55, -0.3, -2.5);
      group.add(exhaust);
    }
    // Upper wing
    const uwing = new THREE.Mesh(new THREE.BoxGeometry(9, 0.12, 1.6), body);
    uwing.position.set(0, 1.4, -0.3);
    group.add(uwing);
    // Lower wing
    const lwing = new THREE.Mesh(new THREE.BoxGeometry(8, 0.12, 1.4), body);
    lwing.position.set(0, -0.3, -0.3);
    group.add(lwing);
    // Wing struts (4 pairs with cross-bracing)
    for (let s = -1; s <= 1; s += 2) {
      for (let fz of [-0.8, 0.1]) {
        const strut = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 1.7, 4), metal);
        strut.position.set(s * 2.8, 0.55, fz);
        group.add(strut);
        // Cross wires
        const wire = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.01, 2.2, 3), mat(0x666666));
        wire.position.set(s * 2.8, 0.55, fz);
        wire.rotation.z = 0.4;
        group.add(wire);
      }
    }
    // Ailerons
    for (let s = -1; s <= 1; s += 2) {
      const aileron = new THREE.Mesh(new THREE.BoxGeometry(2, 0.06, 0.4), accent);
      aileron.position.set(s * 3.5, 1.4, 0.5);
      group.add(aileron);
    }
    // Tail vertical (rudder)
    const tailV = new THREE.Mesh(new THREE.BoxGeometry(0.08, 1.4, 1.2), accent);
    tailV.position.set(0, 0.9, 3.6);
    group.add(tailV);
    // Tail horizontal (elevator)
    const tailH = new THREE.Mesh(new THREE.BoxGeometry(3, 0.08, 0.9), body);
    tailH.position.set(0, 0.3, 3.5);
    group.add(tailH);
    // Tail skid
    const skid = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.4, 4), metal);
    skid.position.set(0, -0.5, 3.3);
    group.add(skid);
    // Landing gear
    for (let s = -1; s <= 1; s += 2) {
      const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 1.4, 6), metal);
      leg.position.set(s*0.9, -1.2, -1.2);
      leg.rotation.z = s * 0.12;
      group.add(leg);
      const wheel = new THREE.Mesh(new THREE.TorusGeometry(0.3, 0.1, 8, 12), mat(0x222222));
      wheel.position.set(s*0.95, -1.9, -1.2);
      wheel.rotation.y = Math.PI/2;
      group.add(wheel);
    }
    // Axle
    const axle = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 2, 4), metal);
    axle.rotation.z = Math.PI/2;
    axle.position.set(0, -1.85, -1.2);
    group.add(axle);
    // Cockpit windscreen
    const glass = mat(0xaaddff, { transparent: true, opacity: 0.25 });
    const windscreen = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.5, 0.02), glass);
    windscreen.position.set(0, 0.8, -1.5);
    windscreen.rotation.x = -0.25;
    group.add(windscreen);
    // Propeller (2 blades)
    const propGroup = new THREE.Group();
    const blade1 = new THREE.Mesh(new THREE.BoxGeometry(0.18, 2.8, 0.06), dark);
    propGroup.add(blade1);
    const blade2 = new THREE.Mesh(new THREE.BoxGeometry(2.8, 0.18, 0.06), dark);
    propGroup.add(blade2);
    propGroup.position.z = -3.55; propGroup.name = 'propeller';
    group.add(propGroup);
    group.scale.setScalar(0.55);
    return group;
  }
  buildCessna() {
    const group = new THREE.Group();
    const mat = (color, opts={}) => new THREE.MeshStandardMaterial({ color, roughness: 0.55, ...opts });
    const white = mat(0xeeeeee);
    const blue = mat(0x1166dd);
    const metal = mat(0x888888, { metalness: 0.5 });
    const glass = mat(0xaaddff, { transparent: true, opacity: 0.25 });
    // Fuselage — rounded
    const fuseMain = new THREE.Mesh(new THREE.CylinderGeometry(0.75, 0.7, 5, 10), white);
    fuseMain.rotation.x = Math.PI/2;
    group.add(fuseMain);
    const fuseTail = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.3, 3, 8), white);
    fuseTail.rotation.x = Math.PI/2;
    fuseTail.position.z = 3;
    group.add(fuseTail);
    // Blue stripes
    for (let s = -1; s <= 1; s += 2) {
      const stripe = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.25, 7), blue);
      stripe.position.set(s * 0.73, 0, 0.5);
      group.add(stripe);
    }
    // Red accent line
    const redLine = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.08, 6), mat(0xcc2222));
    redLine.position.set(0.74, 0.2, 0.5);
    group.add(redLine);
    const redLine2 = redLine.clone(); redLine2.position.x = -0.74;
    group.add(redLine2);
    // Windshield
    const windshield = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.7, 0.02), glass);
    windshield.position.set(0, 0.5, -1.8);
    windshield.rotation.x = -0.3;
    group.add(windshield);
    // Side windows
    for (let s = -1; s <= 1; s += 2) {
      const sideWin = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.5, 1.2), glass);
      sideWin.position.set(s * 0.76, 0.3, -0.8);
      group.add(sideWin);
    }
    // High wing with slight dihedral
    const wing = new THREE.Mesh(new THREE.BoxGeometry(12, 0.14, 1.7), white);
    wing.position.set(0, 0.85, -0.3);
    group.add(wing);
    // Flaps
    for (let s = -1; s <= 1; s += 2) {
      const flap = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.08, 0.5), white);
      flap.position.set(s * 2.5, 0.82, 0.3);
      group.add(flap);
    }
    // Wing struts
    for (let s = -1; s <= 1; s += 2) {
      const strut = new THREE.Mesh(new THREE.CylinderGeometry(0.035, 0.035, 2, 5), metal);
      strut.position.set(s * 2.2, 0.1, -0.3);
      strut.rotation.z = s * 0.35;
      group.add(strut);
    }
    // Tail vertical
    const tailV = new THREE.Mesh(new THREE.BoxGeometry(0.08, 1.6, 1.3), white);
    tailV.position.set(0, 0.9, 4.2);
    group.add(tailV);
    // Horizontal stabilizer
    const tailH = new THREE.Mesh(new THREE.BoxGeometry(3.5, 0.08, 0.9), white);
    tailH.position.set(0, 0.2, 4.2);
    group.add(tailH);
    // Nose cowling
    const nose = new THREE.Mesh(new THREE.CylinderGeometry(0.38, 0.65, 1.2, 10), metal);
    nose.rotation.x = Math.PI/2; nose.position.z = -3.2;
    group.add(nose);
    // Spinner
    const spinner = new THREE.Mesh(new THREE.ConeGeometry(0.25, 0.5, 8), mat(0xdddddd, { metalness: 0.6 }));
    spinner.rotation.x = -Math.PI/2;
    spinner.position.z = -3.95;
    group.add(spinner);
    // Tricycle gear
    const noseGear = new THREE.Mesh(new THREE.CylinderGeometry(0.035, 0.035, 0.9, 5), metal);
    noseGear.position.set(0, -1, -2.2);
    group.add(noseGear);
    const noseWheel = new THREE.Mesh(new THREE.TorusGeometry(0.2, 0.07, 8, 10), mat(0x222222));
    noseWheel.position.set(0, -1.45, -2.2); noseWheel.rotation.y = Math.PI/2;
    group.add(noseWheel);
    for (let s = -1; s <= 1; s += 2) {
      const mainGear = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 1, 5), metal);
      mainGear.position.set(s*0.9, -1.05, 0);
      group.add(mainGear);
      const mainWheel = new THREE.Mesh(new THREE.TorusGeometry(0.25, 0.08, 8, 10), mat(0x222222));
      mainWheel.position.set(s*0.9, -1.55, 0); mainWheel.rotation.y = Math.PI/2;
      group.add(mainWheel);
      // Wheel pants/fairings
      const pant = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.2, 0.6, 6), white);
      pant.rotation.x = Math.PI/2;
      pant.position.set(s*0.9, -1.5, 0);
      group.add(pant);
    }
    // Propeller
    const propGroup = new THREE.Group();
    const blade1 = new THREE.Mesh(new THREE.BoxGeometry(0.14, 2.5, 0.05), mat(0x222222));
    propGroup.add(blade1);
    propGroup.position.z = -4.1; propGroup.name = 'propeller';
    group.add(propGroup);
    // Navigation lights
    for (let s = -1; s <= 1; s += 2) {
      const navLight = new THREE.Mesh(
        new THREE.SphereGeometry(0.06, 4, 3),
        mat(s === -1 ? 0xff0000 : 0x00ff00, { emissive: s === -1 ? 0xff0000 : 0x00ff00, emissiveIntensity: 0.5 })
      );
      navLight.position.set(s * 6, 0.85, -0.3);
      group.add(navLight);
    }
    group.scale.setScalar(0.55);
    return group;
  }
  buildGlider() {
    const group = new THREE.Group();
    const mat = (color, opts={}) => new THREE.MeshStandardMaterial({ color, roughness: 0.4, ...opts });
    const white = mat(0xf0f0f0);
    const glass = mat(0xaaddff, { transparent: true, opacity: 0.3 });
    // Slim fuselage
    const fuseNose = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.4, 3, 8), white);
    fuseNose.rotation.x = Math.PI/2;
    fuseNose.position.z = -1;
    group.add(fuseNose);
    const fuseTail = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.35, 5, 8), white);
    fuseTail.rotation.x = Math.PI/2;
    fuseTail.position.z = 2;
    group.add(fuseTail);
    // Orange competition stripe on fuselage
    const orange = mat(0xff6600);
    const fuseStripe = new THREE.Mesh(new THREE.CylinderGeometry(0.37, 0.42, 2.5, 8), orange);
    fuseStripe.rotation.x = Math.PI/2;
    fuseStripe.position.set(0, 0.02, -0.8);
    fuseStripe.scale.set(1, 1, 0.12);
    group.add(fuseStripe);
    // Bubble canopy
    const canopy = new THREE.Mesh(
      new THREE.SphereGeometry(0.45, 10, 8, 0, Math.PI*2, 0, Math.PI*0.55),
      glass
    );
    canopy.position.set(0, 0.35, -1.8);
    group.add(canopy);
    // Very long wings with taper
    for (let s = -1; s <= 1; s += 2) {
      const wingInner = new THREE.Mesh(new THREE.BoxGeometry(5, 0.1, 1.3), white);
      wingInner.position.set(s * 3, 0.15, -0.3);
      group.add(wingInner);
      const wingOuter = new THREE.Mesh(new THREE.BoxGeometry(5, 0.08, 0.9), white);
      wingOuter.position.set(s * 7.5, 0.25, -0.3);
      group.add(wingOuter);
      // Orange wing tip accent
      const tipAccent = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.1, 0.9), orange);
      tipAccent.position.set(s * 9.5, 0.25, -0.3);
      group.add(tipAccent);
      // Winglet
      const winglet = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.6, 0.5), orange);
      winglet.position.set(s * 10, 0.5, -0.3);
      group.add(winglet);
    }
    // T-tail
    const tailBoom = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.2, 1.5, 6), white);
    tailBoom.rotation.x = Math.PI/2;
    tailBoom.position.set(0, 0, 4.5);
    group.add(tailBoom);
    const tailV = new THREE.Mesh(new THREE.BoxGeometry(0.06, 1.5, 0.9), white);
    tailV.position.set(0, 0.85, 5);
    group.add(tailV);
    const tailH = new THREE.Mesh(new THREE.BoxGeometry(3.5, 0.06, 0.6), white);
    tailH.position.set(0, 1.6, 5);
    group.add(tailH);
    group.scale.setScalar(0.55);
    return group;
  }
  buildParaglider() {
    const group = new THREE.Group();
    const mat = (color, opts={}) => new THREE.MeshStandardMaterial({ color, roughness: 0.7, ...opts });
    // Canopy — more cells visible
    const canopyGeo = new THREE.SphereGeometry(4.5, 20, 10, 0, Math.PI*2, 0.25, 0.55);
    canopyGeo.scale(1, 0.12, 0.35);
    const canopy = new THREE.Mesh(canopyGeo, mat(0xff8800, { side: THREE.DoubleSide }));
    canopy.position.set(0, 4.5, 0);
    group.add(canopy);
    // Canopy cell lines
    for (let i = -4; i <= 4; i++) {
      const lineGeo = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(i * 0.8, 4.3, -1.2), new THREE.Vector3(i * 0.8, 4.6, 1.2)
      ]);
      group.add(new THREE.Line(lineGeo, new THREE.LineBasicMaterial({ color: 0xcc6600 })));
    }
    // Suspension lines (A, B, C rows)
    const lineMat = new THREE.LineBasicMaterial({ color: 0x555555 });
    for (let row = -1; row <= 1; row++) {
      for (let i = -4; i <= 4; i++) {
        const pts = [
          new THREE.Vector3(i*0.5, 4.0, row * 0.5),
          new THREE.Vector3(i*0.06, 0.1, row * 0.1)
        ];
        group.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), lineMat));
      }
    }
    // Pilot body — more detailed
    const torso = new THREE.Mesh(new THREE.BoxGeometry(0.55, 0.75, 0.45), mat(0x333333));
    torso.position.set(0, -0.35, 0);
    group.add(torso);
    // Harness
    const harness = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.2, 0.5), mat(0x444444));
    harness.position.set(0, -0.1, 0);
    group.add(harness);
    // Arms
    for (let s = -1; s <= 1; s += 2) {
      const arm = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.04, 0.6, 5), mat(0xddaa88));
      arm.position.set(s*0.4, -0.1, -0.1);
      arm.rotation.z = s * 0.4;
      group.add(arm);
    }
    // Legs
    for (let s = -1; s <= 1; s += 2) {
      const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.09, 0.07, 1, 6), mat(0x333355));
      leg.position.set(s*0.16, -1.1, 0.1);
      leg.rotation.x = 0.3;
      group.add(leg);
      const boot = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.08, 0.18), mat(0x222222));
      boot.position.set(s*0.16, -1.65, 0.2);
      group.add(boot);
    }
    // Head with helmet
    const head = new THREE.Mesh(new THREE.SphereGeometry(0.17, 8, 6), mat(0xddaa88));
    head.position.set(0, 0.25, 0);
    group.add(head);
    const helmet = new THREE.Mesh(new THREE.SphereGeometry(0.19, 8, 6, 0, Math.PI*2, 0, Math.PI*0.6), mat(0xcc3333));
    helmet.position.set(0, 0.28, 0);
    group.add(helmet);
    group.scale.setScalar(0.55);
    return group;
  }
  buildHangGlider() {
    const group = new THREE.Group();
    const mat = (color, opts={}) => new THREE.MeshStandardMaterial({ color, roughness: 0.6, ...opts });
    const tube = mat(0x999999, { metalness: 0.4 });
    // Delta wing — more detailed shape
    const wingShape = new THREE.Shape();
    wingShape.moveTo(0, -5);
    wingShape.lineTo(-6, 2);
    wingShape.lineTo(-5.5, 2.2);
    wingShape.lineTo(0, -3);
    wingShape.lineTo(5.5, 2.2);
    wingShape.lineTo(6, 2);
    wingShape.closePath();
    const wingGeo = new THREE.ShapeGeometry(wingShape);
    wingGeo.rotateX(-Math.PI/2);
    const wing = new THREE.Mesh(wingGeo, mat(0x2266dd, { side: THREE.DoubleSide }));
    wing.position.set(0, 1.8, 0);
    group.add(wing);
    // White panel design on wing
    const panelShape = new THREE.Shape();
    panelShape.moveTo(0, -3);
    panelShape.lineTo(-2.5, 1);
    panelShape.lineTo(2.5, 1);
    panelShape.closePath();
    const panelGeo = new THREE.ShapeGeometry(panelShape);
    panelGeo.rotateX(-Math.PI/2);
    const panel = new THREE.Mesh(panelGeo, mat(0xffffff, { side: THREE.DoubleSide }));
    panel.position.set(0, 1.82, 0);
    group.add(panel);
    // Leading edge battens
    for (let s = -1; s <= 1; s += 2) {
      const batten = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 7, 4), tube);
      batten.rotation.z = s * 0.35;
      batten.rotation.x = Math.PI/2;
      batten.position.set(s * 2.5, 1.8, -0.8);
      group.add(batten);
    }
    // A-frame control bar
    const bar = new THREE.Mesh(new THREE.CylinderGeometry(0.035, 0.035, 2.2, 5), tube);
    bar.rotation.z = Math.PI/2;
    bar.position.set(0, 0, 0.5);
    group.add(bar);
    for (let s = -1; s <= 1; s += 2) {
      const upright = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 2.2, 5), tube);
      upright.position.set(s*0.7, 0.9, 0.3);
      upright.rotation.z = s*0.28;
      group.add(upright);
    }
    // Keel
    const keel = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 6, 4), tube);
    keel.rotation.x = Math.PI/2;
    keel.position.set(0, 1.8, -0.5);
    group.add(keel);
    // Crossbar
    const crossbar = new THREE.Mesh(new THREE.CylinderGeometry(0.025, 0.025, 5, 4), tube);
    crossbar.rotation.z = Math.PI/2;
    crossbar.position.set(0, 1.7, 0.5);
    group.add(crossbar);
    // Pilot (prone, more detailed)
    const torso = new THREE.Mesh(new THREE.CylinderGeometry(0.17, 0.14, 1.4, 7), mat(0x333333));
    torso.rotation.x = Math.PI/2;
    torso.position.set(0, -0.2, 0.3);
    group.add(torso);
    const head = new THREE.Mesh(new THREE.SphereGeometry(0.14, 7, 5), mat(0xddaa88));
    head.position.set(0, -0.05, -0.5);
    group.add(head);
    const helmet = new THREE.Mesh(new THREE.SphereGeometry(0.16, 7, 5, 0, Math.PI*2, 0, Math.PI*0.6), mat(0x3333aa));
    helmet.position.set(0, -0.02, -0.5);
    group.add(helmet);
    // Legs
    for (let s = -1; s <= 1; s += 2) {
      const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.07, 0.05, 1, 5), mat(0x333355));
      leg.rotation.x = Math.PI/2;
      leg.position.set(s * 0.08, -0.3, 1.2);
      group.add(leg);
    }
    // Harness/pod
    const pod = new THREE.Mesh(new THREE.CylinderGeometry(0.18, 0.15, 1.8, 6), mat(0x444444));
    pod.rotation.x = Math.PI/2;
    pod.position.set(0, -0.25, 0.5);
    group.add(pod);
    group.scale.setScalar(0.55);
    return group;
  }
  buildF117() {
    const group = new THREE.Group();
    const mat = (color, opts={}) => new THREE.MeshStandardMaterial({ color, roughness: 0.5, ...opts });
    const black = mat(0x1a1a1a);
    const darkGray = mat(0x222222);
    const canopyMat = mat(0xaa8833, { transparent: true, opacity: 0.4, metalness: 0.3 });
    const metal = mat(0x333333, { metalness: 0.5 });
    // Main fuselage — wide flat diamond cross-section using boxes
    const fuseTop = new THREE.Mesh(new THREE.BoxGeometry(2.0, 0.4, 6.0), black);
    fuseTop.position.set(0, 0.1, 0);
    group.add(fuseTop);
    const fuseBelly = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.35, 5.8), black);
    fuseBelly.position.set(0, -0.2, 0);
    group.add(fuseBelly);
    // Angled side panels (faceted stealth look)
    for (let s = -1; s <= 1; s += 2) {
      const sidePanel = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.6, 5.5), black);
      sidePanel.position.set(s * 1.1, -0.05, 0);
      sidePanel.rotation.z = s * 0.4;
      group.add(sidePanel);
    }
    // Angular nose — wedge shape using tapered box
    const noseTip = new THREE.Mesh(new THREE.ConeGeometry(0.5, 2.8, 4), black);
    noseTip.rotation.x = -Math.PI / 2;
    noseTip.rotation.y = Math.PI / 4;
    noseTip.position.set(0, -0.05, -4.2);
    group.add(noseTip);
    // Nose blend section
    const noseBlend = new THREE.Mesh(new THREE.BoxGeometry(1.4, 0.5, 1.2), black);
    noseBlend.position.set(0, 0, -3.0);
    group.add(noseBlend);
    // Canopy — small angular gold-tinted
    const canopy = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.3, 1.0), canopyMat);
    canopy.position.set(0, 0.5, -1.5);
    group.add(canopy);
    // Canopy frame edges
    for (let s = -1; s <= 1; s += 2) {
      const frame = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.32, 1.05), darkGray);
      frame.position.set(s * 0.37, 0.5, -1.5);
      group.add(frame);
    }
    const frameFront = new THREE.Mesh(new THREE.BoxGeometry(0.75, 0.32, 0.04), darkGray);
    frameFront.position.set(0, 0.5, -2.0);
    group.add(frameFront);
    // Highly swept delta wings — thick box geometry
    for (let s = -1; s <= 1; s += 2) {
      // Inner wing section
      const wingInner = new THREE.Mesh(new THREE.BoxGeometry(3.0, 0.1, 3.5), black);
      wingInner.position.set(s * 2.4, -0.15, 0.3);
      wingInner.rotation.y = s * -0.15;
      group.add(wingInner);
      // Outer wing section (swept back more)
      const wingOuter = new THREE.Mesh(new THREE.BoxGeometry(2.0, 0.08, 2.0), black);
      wingOuter.position.set(s * 4.5, -0.15, 1.0);
      wingOuter.rotation.y = s * -0.25;
      group.add(wingOuter);
    }
    // Tail section — tapered rear
    const tailBody = new THREE.Mesh(new THREE.BoxGeometry(1.6, 0.35, 2.5), black);
    tailBody.position.set(0, 0, 2.8);
    group.add(tailBody);
    // V-tail — two angled stabilizers
    for (let s = -1; s <= 1; s += 2) {
      const tail = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.08, 1.4), black);
      tail.position.set(s * 1.0, 0.5, 3.5);
      tail.rotation.z = s * 0.55;
      group.add(tail);
    }
    // Flat rectangular exhaust slot
    const exhaustSlot = new THREE.Mesh(new THREE.BoxGeometry(1.6, 0.25, 0.4), darkGray);
    exhaustSlot.position.set(0, -0.1, 4.0);
    group.add(exhaustSlot);
    const exhaustInner = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.15, 0.2), mat(0x111111));
    exhaustInner.position.set(0, -0.1, 4.15);
    group.add(exhaustInner);
    // Afterburner flame cone
    const abGeo = new THREE.ConeGeometry(0.3, 2.5, 8);
    const abMat = new THREE.MeshStandardMaterial({ color: 0xff6600, emissive: 0xff4400, emissiveIntensity: 1.5, transparent: true, opacity: 0.8 });
    const afterburner = new THREE.Mesh(abGeo, abMat);
    afterburner.rotation.x = Math.PI / 2;
    afterburner.position.set(0, -0.1, 5.4);
    afterburner.name = 'afterburner';
    afterburner.visible = false;
    group.add(afterburner);
    // Tricycle landing gear
    const noseGearLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.8, 5), metal);
    noseGearLeg.position.set(0, -0.7, -2.5);
    group.add(noseGearLeg);
    const noseWheel = new THREE.Mesh(new THREE.TorusGeometry(0.2, 0.07, 8, 10), mat(0x222222));
    noseWheel.position.set(0, -1.1, -2.5);
    noseWheel.rotation.y = Math.PI / 2;
    group.add(noseWheel);
    for (let s = -1; s <= 1; s += 2) {
      const mainLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.9, 5), metal);
      mainLeg.position.set(s * 1.2, -0.75, 0.5);
      group.add(mainLeg);
      const mainWheel = new THREE.Mesh(new THREE.TorusGeometry(0.22, 0.08, 8, 10), mat(0x222222));
      mainWheel.position.set(s * 1.2, -1.2, 0.5);
      mainWheel.rotation.y = Math.PI / 2;
      group.add(mainWheel);
    }
    group.scale.setScalar(0.55);
    return group;
  }
  buildF14() {
    const group = new THREE.Group();
    const mat = (color, opts={}) => new THREE.MeshStandardMaterial({ color, roughness: 0.45, ...opts });
    const gray = mat(0x999999);
    const darkGray = mat(0x555555);
    const accent = mat(0x444444);
    const metal = mat(0x666666, { metalness: 0.5 });
    const canopyGlass = mat(0xaaddff, { transparent: true, opacity: 0.25 });
    // Long sleek fuselage
    const fuseMain = new THREE.Mesh(new THREE.CylinderGeometry(0.7, 0.85, 7, 10), gray);
    fuseMain.rotation.x = Math.PI / 2;
    group.add(fuseMain);
    const fuseTail = new THREE.Mesh(new THREE.CylinderGeometry(0.55, 0.7, 4, 8), gray);
    fuseTail.rotation.x = Math.PI / 2;
    fuseTail.position.set(0, 0, 4.5);
    group.add(fuseTail);
    // Nose cone
    const noseCone = new THREE.Mesh(new THREE.ConeGeometry(0.55, 3, 10), gray);
    noseCone.rotation.x = -Math.PI / 2;
    noseCone.position.set(0, 0, -5);
    group.add(noseCone);
    // Radome tip
    const radome = new THREE.Mesh(new THREE.ConeGeometry(0.2, 0.8, 8), darkGray);
    radome.rotation.x = -Math.PI / 2;
    radome.position.set(0, 0, -6.8);
    group.add(radome);
    // Tandem two-seat bubble canopy
    const canopyBase = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.1, 2.5), accent);
    canopyBase.position.set(0, 0.7, -2.5);
    group.add(canopyBase);
    const canopyFront = new THREE.Mesh(new THREE.SphereGeometry(0.5, 10, 8, 0, Math.PI * 2, 0, Math.PI * 0.5), canopyGlass);
    canopyFront.position.set(0, 0.72, -3.0);
    canopyFront.scale.set(0.9, 0.6, 1.2);
    group.add(canopyFront);
    const canopyRear = new THREE.Mesh(new THREE.SphereGeometry(0.5, 10, 8, 0, Math.PI * 2, 0, Math.PI * 0.5), canopyGlass);
    canopyRear.position.set(0, 0.72, -2.0);
    canopyRear.scale.set(0.9, 0.6, 1.0);
    group.add(canopyRear);
    // Canopy frame bow
    const canopyBow = new THREE.Mesh(new THREE.BoxGeometry(0.92, 0.04, 0.06), accent);
    canopyBow.position.set(0, 0.95, -2.5);
    group.add(canopyBow);
    // Wing gloves (fixed inner wing sections)
    for (let s = -1; s <= 1; s += 2) {
      const glove = new THREE.Mesh(new THREE.BoxGeometry(2.2, 0.14, 2.8), gray);
      glove.position.set(s * 1.8, -0.1, -0.2);
      group.add(glove);
    }
    // Swept-back variable-sweep wings
    for (let s = -1; s <= 1; s += 2) {
      const wingShape = new THREE.Shape();
      wingShape.moveTo(0, 0);
      wingShape.lineTo(s * 4.5, 0.5);
      wingShape.lineTo(s * 4.0, -1.5);
      wingShape.lineTo(0, -1.5);
      wingShape.closePath();
      const wingGeo = new THREE.ShapeGeometry(wingShape);
      wingGeo.rotateX(-Math.PI / 2);
      const wing = new THREE.Mesh(wingGeo, new THREE.MeshStandardMaterial({ color: 0x999999, roughness: 0.45, side: THREE.DoubleSide }));
      wing.position.set(s * 2.8, -0.1, -0.3);
      group.add(wing);
    }
    // Twin vertical tails
    for (let s = -1; s <= 1; s += 2) {
      const tailV = new THREE.Mesh(new THREE.BoxGeometry(0.08, 2.0, 1.8), gray);
      tailV.position.set(s * 0.9, 1.2, 5.5);
      group.add(tailV);
      // Rudder hinge line
      const rudderLine = new THREE.Mesh(new THREE.BoxGeometry(0.02, 1.8, 0.03), darkGray);
      rudderLine.position.set(s * 0.9, 1.2, 6.2);
      group.add(rudderLine);
    }
    // Horizontal stabilizer
    const hStab = new THREE.Mesh(new THREE.BoxGeometry(5.5, 0.08, 1.5), gray);
    hStab.position.set(0, 0.1, 5.8);
    group.add(hStab);
    // Large box intakes on fuselage sides
    for (let s = -1; s <= 1; s += 2) {
      const intake = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.9, 2.5), darkGray);
      intake.position.set(s * 1.2, -0.2, -1.5);
      group.add(intake);
      const intakeInner = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.7, 0.1), mat(0x111111));
      intakeInner.position.set(s * 1.2, -0.2, -2.75);
      group.add(intakeInner);
      // Intake ramp
      const ramp = new THREE.Mesh(new THREE.BoxGeometry(0.75, 0.06, 2.4), accent);
      ramp.position.set(s * 1.2, 0.25, -1.5);
      group.add(ramp);
    }
    // Twin engine nacelles
    for (let s = -1; s <= 1; s += 2) {
      const nacelle = new THREE.Mesh(new THREE.CylinderGeometry(0.55, 0.5, 5, 8), darkGray);
      nacelle.rotation.x = Math.PI / 2;
      nacelle.position.set(s * 1.0, -0.1, 3.5);
      group.add(nacelle);
      // Exhaust nozzle
      const nozzle = new THREE.Mesh(new THREE.CylinderGeometry(0.45, 0.5, 0.6, 10), mat(0x333333, { metalness: 0.6 }));
      nozzle.rotation.x = Math.PI / 2;
      nozzle.position.set(s * 1.0, -0.1, 6.1);
      group.add(nozzle);
      const nozzleInner = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.42, 0.3, 10), mat(0x111111));
      nozzleInner.rotation.x = Math.PI / 2;
      nozzleInner.position.set(s * 1.0, -0.1, 6.3);
      group.add(nozzleInner);
      // Afterburner flame cone
      const abGeo = new THREE.ConeGeometry(0.35, 3, 8);
      const abMat = new THREE.MeshStandardMaterial({ color: 0xff6600, emissive: 0xff4400, emissiveIntensity: 1.5, transparent: true, opacity: 0.8 });
      const ab = new THREE.Mesh(abGeo, abMat);
      ab.rotation.x = Math.PI / 2;
      ab.position.set(s * 1.0, -0.1, 7.8);
      ab.name = s === -1 ? 'afterburner_L' : 'afterburner_R';
      ab.visible = false;
      group.add(ab);
    }
    // Navy-style markings — tail stripe
    for (let s = -1; s <= 1; s += 2) {
      const stripe = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1.6, 0.15), mat(0xff8800));
      stripe.position.set(s * 0.9, 1.2, 5.0);
      group.add(stripe);
    }
    // Wing root stripe
    const wingStripe = new THREE.Mesh(new THREE.BoxGeometry(2, 0.02, 0.15), mat(0xdddddd));
    wingStripe.position.set(0, 0.05, -1.0);
    group.add(wingStripe);
    // Tricycle landing gear
    const noseGearLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 1.0, 5), metal);
    noseGearLeg.position.set(0, -0.9, -3.5);
    group.add(noseGearLeg);
    const noseWheel = new THREE.Mesh(new THREE.TorusGeometry(0.22, 0.08, 8, 10), mat(0x222222));
    noseWheel.position.set(0, -1.4, -3.5);
    noseWheel.rotation.y = Math.PI / 2;
    group.add(noseWheel);
    for (let s = -1; s <= 1; s += 2) {
      const mainLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.045, 0.045, 1.1, 5), metal);
      mainLeg.position.set(s * 1.5, -0.95, 0);
      group.add(mainLeg);
      const mainWheel = new THREE.Mesh(new THREE.TorusGeometry(0.25, 0.09, 8, 10), mat(0x222222));
      mainWheel.position.set(s * 1.5, -1.5, 0);
      mainWheel.rotation.y = Math.PI / 2;
      group.add(mainWheel);
    }
    group.scale.setScalar(0.55);
    return group;
  }
}

// ─── AirstripSystem ───
class AirstripSystem {
  constructor(scene, noise) {
    this.scene = scene;
    this.noise = noise;
    this.strips = new Map();
    this.gridSpacing = 1500;
    this.spawnStripPlaced = false;
  }
  clearAll() {
    this.strips.forEach(s => { this.scene.remove(s.group); });
    this.strips.clear();
    this.spawnStripPlaced = false;
  }
  isOnRunway(x, z) {
    for (const [, strip] of this.strips) {
      const dx = Math.abs(x - strip.x);
      const dz = Math.abs(z - strip.z);
      if (dx < 110 && dz < 14) return true;
    }
    return false;
  }
  getRunwayHeight(x, z) {
    for (const [, strip] of this.strips) {
      const dx = Math.abs(x - strip.x);
      const dz = Math.abs(z - strip.z);
      if (dx < 115 && dz < 18) return strip.y;
    }
    return null;
  }
  buildAirstrip(group, sx, sz, h) {
    const runwayMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2e, roughness: 0.9 });
    const markMat = new THREE.MeshStandardMaterial({ color: 0xdddddd, roughness: 0.8 });
    const yellowMat = new THREE.MeshStandardMaterial({ color: 0xddcc44, roughness: 0.8 });
    // Main runway
    const runway = new THREE.Mesh(new THREE.BoxGeometry(220, 0.4, 22), runwayMat);
    runway.position.set(sx, h + 0.2, sz);
    group.add(runway);
    // Taxiway apron
    const apron = new THREE.Mesh(new THREE.BoxGeometry(40, 0.35, 30), runwayMat);
    apron.position.set(sx - 30, h + 0.17, sz + 25);
    group.add(apron);
    // Center line dashes
    for (let i = -10; i <= 10; i++) {
      const mark = new THREE.Mesh(new THREE.BoxGeometry(5, 0.02, 0.35), markMat);
      mark.position.set(sx + i * 10, h + 0.42, sz);
      group.add(mark);
    }
    // Threshold markings (piano keys)
    for (let side = -1; side <= 1; side += 2) {
      for (let i = -4; i <= 4; i++) {
        const tm = new THREE.Mesh(new THREE.BoxGeometry(4, 0.02, 0.6), markMat);
        tm.position.set(sx + side * 105, h + 0.42, sz + i * 2);
        group.add(tm);
      }
      // Edge lines
      const edgeLine = new THREE.Mesh(new THREE.BoxGeometry(210, 0.02, 0.3), markMat);
      edgeLine.position.set(sx, h + 0.42, sz + side * 10.5);
      group.add(edgeLine);
    }
    // Runway numbers (boxes as simplified numerals)
    for (let side = -1; side <= 1; side += 2) {
      const numBlock = new THREE.Mesh(new THREE.BoxGeometry(4, 0.02, 6), markMat);
      numBlock.position.set(sx + side * 95, h + 0.42, sz);
      numBlock.material = markMat.clone();
      numBlock.material.opacity = 0.5;
      numBlock.material.transparent = true;
      group.add(numBlock);
    }
    // PAPI lights (approach slope indicator)
    for (let side = -1; side <= 1; side += 2) {
      for (let i = 0; i < 4; i++) {
        const papi = new THREE.Mesh(
          new THREE.BoxGeometry(0.5, 0.5, 0.5),
          new THREE.MeshStandardMaterial({ color: i < 2 ? 0xff2200 : 0xffffff, emissive: i < 2 ? 0xff2200 : 0xffffff, emissiveIntensity: 0.8 })
        );
        papi.position.set(sx + side * 108, h + 0.5, sz - 8 + i * 1.5);
        group.add(papi);
      }
    }
    // Windsock
    const poleMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.4 });
    const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 8, 6), poleMat);
    pole.position.set(sx + 115, h + 4, sz + 18);
    group.add(pole);
    const sock = new THREE.Mesh(new THREE.ConeGeometry(0.6, 2.5, 6), new THREE.MeshStandardMaterial({ color: 0xff6600 }));
    sock.rotation.z = -Math.PI / 2;
    sock.position.set(sx + 116.5, h + 8, sz + 18);
    group.add(sock);
    const sockStripe = new THREE.Mesh(new THREE.ConeGeometry(0.62, 0.8, 6), new THREE.MeshStandardMaterial({ color: 0xffffff }));
    sockStripe.rotation.z = -Math.PI / 2;
    sockStripe.position.set(sx + 116, h + 8, sz + 18);
    group.add(sockStripe);
    // Terminal/hangar building
    const bldgMat = new THREE.MeshStandardMaterial({ color: 0xccbbaa, roughness: 0.8 });
    const roofMat = new THREE.MeshStandardMaterial({ color: 0x556655, roughness: 0.7 });
    const bldg = new THREE.Mesh(new THREE.BoxGeometry(14, 5, 10), bldgMat);
    bldg.position.set(sx - 35, h + 2.5, sz + 30);
    group.add(bldg);
    const roof = new THREE.Mesh(new THREE.BoxGeometry(15, 0.4, 11), roofMat);
    roof.position.set(sx - 35, h + 5.2, sz + 30);
    group.add(roof);
    // Hangar
    const hangarMat = new THREE.MeshStandardMaterial({ color: 0x889988, metalness: 0.3, roughness: 0.6 });
    const hangar = new THREE.Mesh(new THREE.BoxGeometry(18, 7, 16), hangarMat);
    hangar.position.set(sx - 15, h + 3.5, sz + 32);
    group.add(hangar);
    const hangarDoor = new THREE.Mesh(new THREE.BoxGeometry(12, 5.5, 0.2), new THREE.MeshStandardMaterial({ color: 0x667766 }));
    hangarDoor.position.set(sx - 15, h + 2.75, sz + 24);
    group.add(hangarDoor);
    // Control tower
    const towerMat = new THREE.MeshStandardMaterial({ color: 0xddddcc, roughness: 0.7 });
    const towerBase = new THREE.Mesh(new THREE.BoxGeometry(4, 16, 4), towerMat);
    towerBase.position.set(sx - 50, h + 8, sz + 28);
    group.add(towerBase);
    const towerCab = new THREE.Mesh(new THREE.BoxGeometry(6, 3, 6), new THREE.MeshStandardMaterial({ color: 0x446644 }));
    towerCab.position.set(sx - 50, h + 17.5, sz + 28);
    group.add(towerCab);
    const towerGlass = new THREE.Mesh(
      new THREE.BoxGeometry(5.5, 2, 5.5),
      new THREE.MeshStandardMaterial({ color: 0x88bbdd, transparent: true, opacity: 0.4, metalness: 0.3 })
    );
    towerGlass.position.set(sx - 50, h + 17.5, sz + 28);
    group.add(towerGlass);
    // Parking area with lines
    for (let i = 0; i < 3; i++) {
      const parkLine = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.02, 8), yellowMat);
      parkLine.position.set(sx - 25 + i * 10, h + 0.38, sz + 25);
      group.add(parkLine);
    }
    // Runway edge lights
    for (let i = -10; i <= 10; i++) {
      for (let side = -1; side <= 1; side += 2) {
        const light = new THREE.Mesh(
          new THREE.SphereGeometry(0.15, 4, 3),
          new THREE.MeshStandardMaterial({ color: 0x88aaff, emissive: 0x4466aa, emissiveIntensity: 0.5 })
        );
        light.position.set(sx + i * 10, h + 0.5, sz + side * 11.5);
        group.add(light);
      }
    }
    // Airport beacon — 25m tall pylon with bright green emissive sphere
    const beaconPoleMat = new THREE.MeshStandardMaterial({ color: 0x666666, metalness: 0.4 });
    const beaconPole = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.2, 25, 6), beaconPoleMat);
    beaconPole.position.set(sx - 50, h + 12.5, sz + 40);
    group.add(beaconPole);
    const beaconLight = new THREE.Mesh(
      new THREE.SphereGeometry(2, 10, 8),
      new THREE.MeshStandardMaterial({ color: 0x00ff44, emissive: 0x00ff44, emissiveIntensity: 2.0 })
    );
    beaconLight.position.set(sx - 50, h + 25, sz + 40);
    group.add(beaconLight);
    // Approach lights — row of 5 bright lights extending 50m from each runway threshold
    const approachLightMat = new THREE.MeshStandardMaterial({ color: 0xffffaa, emissive: 0xffdd66, emissiveIntensity: 1.5 });
    for (let side = -1; side <= 1; side += 2) {
      for (let i = 1; i <= 5; i++) {
        const appLight = new THREE.Mesh(new THREE.SphereGeometry(0.4, 6, 4), approachLightMat);
        appLight.position.set(sx + side * (110 + i * 10), h + 1.5, sz);
        group.add(appLight);
        // Light pole
        const appPole = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 1.5, 4), beaconPoleMat);
        appPole.position.set(sx + side * (110 + i * 10), h + 0.75, sz);
        group.add(appPole);
      }
    }
  }
  generateForChunk(cx, cz, terrain) {
    const ox = cx * CHUNK_SIZE, oz = cz * CHUNK_SIZE;
    // Spawn airport (guaranteed near origin)
    if (!this.spawnStripPlaced && Math.abs(cx) <= 1 && Math.abs(cz) <= 1) {
      const spawnKey = 'spawn';
      if (!this.strips.has(spawnKey)) {
        // Find a suitable spot near origin
        let bestX = 80, bestZ = 80, bestH = -999;
        for (let tx = -100; tx <= 200; tx += 40) {
          for (let tz = -100; tz <= 200; tz += 40) {
            const th = terrain.getHeight(tx, tz);
            const wl = terrain.loc.waterLevel || -100;
            if (th > wl + 3 && th < 100 && th > bestH) {
              bestH = th; bestX = tx; bestZ = tz;
            }
          }
        }
        if (bestH > -999) {
          const group = new THREE.Group();
          this.buildAirstrip(group, bestX, bestZ, bestH);
          this.scene.add(group);
          this.strips.set(spawnKey, { group, x: bestX, z: bestZ, y: bestH });
          this.spawnStripPlaced = true;
        }
      }
    }
    // Grid-based airports
    const gx = Math.round(ox / this.gridSpacing) * this.gridSpacing;
    const gz = Math.round(oz / this.gridSpacing) * this.gridSpacing;
    const distToGrid = Math.sqrt((ox - gx) ** 2 + (oz - gz) ** 2);
    if (distToGrid > CHUNK_SIZE * 1.5) return;
    const gKey = 'g' + Math.round(gx / this.gridSpacing) + ',' + Math.round(gz / this.gridSpacing);
    if (this.strips.has(gKey)) return;
    if (gx === 0 && gz === 0) return; // Skip origin, handled by spawn
    const offX = this.noise.noise2D(gx * 0.001, gz * 0.001) * 150;
    const offZ = this.noise.noise2D(gx * 0.001 + 50, gz * 0.001 + 50) * 150;
    const sx = gx + offX, sz = gz + offZ;
    const h = terrain.getHeight(sx, sz);
    const wl = terrain.loc.waterLevel || -100;
    if (h < wl + 3 || h > 500) return;
    const group = new THREE.Group();
    this.buildAirstrip(group, sx, sz, h);
    this.scene.add(group);
    this.strips.set(gKey, { group, x: sx, z: sz, y: h });
  }
  pruneChunks(pcx, pcz) {
    const remove = [];
    this.strips.forEach((strip, key) => {
      if (key === 'spawn') return; // Never prune spawn
      const dx = Math.abs(strip.x - pcx * CHUNK_SIZE);
      const dz = Math.abs(strip.z - pcz * CHUNK_SIZE);
      if (dx > CHUNK_SIZE * (GRID_RADIUS + 4) || dz > CHUNK_SIZE * (GRID_RADIUS + 4))
        remove.push(key);
    });
    remove.forEach(key => {
      this.scene.remove(this.strips.get(key).group);
      this.strips.delete(key);
    });
  }
}

// ─── FlightPhysics ───
class FlightPhysics {
  constructor() {
    this.position = new THREE.Vector3(0, 150, 0);
    this.quaternion = new THREE.Quaternion();
    this.speed = 20;
    this.throttle = 0.3;
    this.aircraft = AIRCRAFT[1];
    this.thermals = [];
    this.crashed = false;
    this.godMode = false;
    this.onGround = false;
    this.generateThermals();
  }
  generateThermals() {
    this.thermals = [];
    for (let i = 0; i < 30; i++) {
      this.thermals.push({
        x: (Math.random() - 0.5) * 3000,
        z: (Math.random() - 0.5) * 3000,
        radius: 30 + Math.random() * 60,
        strength: 5 + Math.random() * 10
      });
    }
  }
  setAircraft(index) {
    this.aircraft = AIRCRAFT[index];
    if (!this.aircraft.hasEngine) this.throttle = 0;
  }
  reset(loc) {
    this.position.set(0, loc.startAlt, 0);
    this.quaternion.identity();
    this.speed = this.aircraft.hasEngine ? 20 : 15;
    this.throttle = this.aircraft.hasEngine ? 0.3 : 0;
    this.generateThermals();
  }
  update(dt, input, terrain, airstrips) {
    if (this.crashed) return;
    dt = Math.min(dt, 0.05);
    const ac = this.aircraft;
    // Input
    const pitchInput = (input.pitch || 0) * ac.pitchRate;
    const acIndex = AIRCRAFT.indexOf(ac);
    const isParagliderOrHangGlider = (acIndex === 3 || acIndex === 4);
    // Ground steering: left/right = yaw turn when on ground at low speed
    if (this.onGround && this.speed < 30 && !isParagliderOrHangGlider && input.roll !== 0) {
      const steerRate = 1.5 * (1 - this.speed / 40);
      const steerQ = new THREE.Quaternion().setFromAxisAngle(
        new THREE.Vector3(0, 1, 0), input.roll * steerRate * dt
      );
      this.quaternion.premultiply(steerQ);
    } else {
      // Normal roll
      const rollInput = (input.roll || 0) * ac.rollRate;
      const rollQ = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 0, -1), rollInput * dt);
      this.quaternion.multiply(rollQ);
    }
    // Apply pitch
    const pitchQ = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), pitchInput * dt);
    this.quaternion.multiply(pitchQ);
    // Yaw from bank (turn coordination)
    const right = new THREE.Vector3(1, 0, 0).applyQuaternion(this.quaternion);
    const bankAngle = Math.asin(Math.max(-1, Math.min(1, -right.y)));
    const yawRate = -bankAngle * ac.yawRate * (this.speed / 30);
    const yawQ = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), yawRate * dt);
    this.quaternion.premultiply(yawQ);
    // Thrust and drag
    if (ac.hasEngine) {
      this.throttle = Math.max(0, Math.min(1, this.throttle + (input.throttleDir || 0) * dt));
      const thrustForce = ac.thrust * this.throttle;
      this.speed += thrustForce * dt;
    }
    const drag = ac.drag * this.speed * this.speed;
    this.speed -= drag * dt;
    // Realistic gravity — full 9.81 component along flight path
    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(this.quaternion);
    const gravEffect = -forward.y * 9.81;
    this.speed += gravEffect * dt;
    // Lift force — creates natural glide when flying level or slightly nose-down
    const liftForce = ac.liftFactor * this.speed * 0.01;
    // Natural glide path: all aircraft sink without thrust (not just unpowered)
    // The sink rate depends on speed and lift — faster with more lift = shallower glide
    let sinkRate = 0;
    if (!this.onGround) {
      if (ac.hasEngine && this.throttle < 0.05) {
        // Engine idle/off: aircraft glides, sinking ~2-4 m/s depending on lift
        sinkRate = 3.0 - liftForce * 0.8;
      } else if (ac.hasEngine) {
        // Partial thrust: slight sink if underpowered, zero if enough thrust
        const thrustNeeded = 9.81 * 0.15; // approximate level flight thrust
        const thrustHave = ac.thrust * this.throttle * 0.03;
        sinkRate = Math.max(0, thrustNeeded - thrustHave);
      } else {
        // Unpowered aircraft (glider, paraglider, hang glider)
        sinkRate = 2.0 - liftForce * 0.5;
      }
    }
    // Thermals for unpowered aircraft
    let thermalLift = 0;
    if (!ac.hasEngine) {
      for (const t of this.thermals) {
        const dx = this.position.x - t.x;
        const dz = this.position.z - t.z;
        const dist = Math.sqrt(dx*dx + dz*dz);
        if (dist < t.radius) {
          thermalLift += t.strength * (1 - dist / t.radius);
        }
      }
    }
    // Terminal velocity: limit speed based on drag, not just maxSpeed
    // When diving straight down, terminal velocity = sqrt(weight / drag)
    const terminalVelocity = Math.min(ac.maxSpeed * 1.4, Math.sqrt(400 / ac.drag));
    // Clamp speed — can exceed maxSpeed in a dive (up to terminal velocity) but not below 1
    this.speed = Math.max(1, Math.min(terminalVelocity, this.speed));
    // Move
    this.position.addScaledVector(forward, this.speed * dt);
    this.position.y += thermalLift * dt;
    // Apply sink rate (reduced by thermals)
    if (sinkRate > 0 && thermalLift < sinkRate) {
      this.position.y -= Math.max(0, sinkRate - thermalLift) * dt;
    }
    // Ground / crash detection
    const groundH = terrain.getHeight(this.position.x, this.position.z);
    const waterLevel = terrain.loc.waterLevel || -100;
    const effectiveGround = Math.max(groundH, waterLevel);
    const clearance = 1;
    const runwayH = airstrips ? airstrips.getRunwayHeight(this.position.x, this.position.z) : null;
    const surfaceH = runwayH !== null ? runwayH : effectiveGround;
    const minAlt = surfaceH + clearance;
    if (this.position.y < minAlt) {
      if (this.godMode) {
        // God mode: bounce
        this.onGround = true;
        this.position.y = minAlt + 2;
        if (forward.y < -0.1) {
          this.speed *= 0.95;
          this.quaternion.slerp(this.getLevelQuat(), 5 * dt);
        }
      } else {
        // Check if this is a safe landing
        const pitchAngle = Math.abs(this.getPitch());
        const bankAngle = Math.abs(this.getRoll());
        const onRunway = airstrips ? airstrips.isOnRunway(this.position.x, this.position.z) : false;
        // Jets land faster — scale safe speed with aircraft max speed
        const safeLandSpeed = Math.max(18, ac.maxSpeed * 0.15);
        const safeRunwaySpeed = Math.max(30, ac.maxSpeed * 0.25);
        const isGentle = this.speed < safeLandSpeed && pitchAngle < 0.25 && bankAngle < 0.3;
        const isSafeLanding = onRunway && this.speed < safeRunwaySpeed && pitchAngle < 0.35 && bankAngle < 0.5;
        if (isGentle || isSafeLanding) {
          // Safe touchdown — slide along surface
          this.onGround = true;
          this.position.y = minAlt;
          this.speed *= 0.98;
          this.quaternion.slerp(this.getLevelQuat(), 3 * dt);
          // Spacebar brakes (not for paraglider/hang glider)
          if (input.brake && !isParagliderOrHangGlider) {
            this.speed *= 0.92;
            if (this.speed < 0.5) this.speed = 0;
          }
        } else if (this.speed > safeLandSpeed * 0.83 || pitchAngle > 0.52 || bankAngle > 1.05) {
          // Crash!
          this.crashed = true;
          this.onGround = true;
          this.position.y = minAlt;
          this.speed = 0;
          return;
        } else {
          // Low-speed bump
          this.onGround = true;
          this.position.y = minAlt;
          this.speed *= 0.95;
          this.quaternion.slerp(this.getLevelQuat(), 5 * dt);
          // Brakes also work on bumps
          if (input.brake && !isParagliderOrHangGlider) {
            this.speed *= 0.92;
            if (this.speed < 0.5) this.speed = 0;
          }
        }
      }
    } else {
      this.onGround = false;
    }
  }
  updateMovementOnly(dt, terrain, airstrips) {
    if (this.crashed) return;
    dt = Math.min(dt, 0.05);
    const ac = this.aircraft;
    // Thrust and drag (autopilot sets throttle directly)
    if (ac.hasEngine) {
      const thrustForce = ac.thrust * this.throttle;
      this.speed += thrustForce * dt;
    }
    const drag = ac.drag * this.speed * this.speed;
    this.speed -= drag * dt;
    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(this.quaternion);
    const gravEffect = -forward.y * 9.81 * 0.3;
    this.speed += gravEffect * dt;
    const liftForce = ac.liftFactor * this.speed * 0.01;
    let thermalLift = 0;
    if (!ac.hasEngine) {
      for (const t of this.thermals) {
        const dx = this.position.x - t.x;
        const dz = this.position.z - t.z;
        const dist = Math.sqrt(dx*dx + dz*dz);
        if (dist < t.radius) thermalLift += t.strength * (1 - dist / t.radius);
      }
    }
    this.speed = Math.max(2, Math.min(ac.maxSpeed, this.speed));
    this.position.addScaledVector(forward, this.speed * dt);
    this.position.y += thermalLift * dt;
    if (!ac.hasEngine && thermalLift < 1) {
      const sinkRate = 2 - liftForce * 0.5;
      this.position.y -= Math.max(0, sinkRate) * dt;
    }
    // Ground avoidance (god mode typically on during autopilot)
    const groundH = terrain.getHeight(this.position.x, this.position.z);
    const waterLevel = terrain.loc.waterLevel || -100;
    const effectiveGround = Math.max(groundH, waterLevel);
    const runwayH = airstrips ? airstrips.getRunwayHeight(this.position.x, this.position.z) : null;
    const surfaceH = runwayH !== null ? runwayH : effectiveGround;
    const minAlt = surfaceH + 2;
    if (this.position.y < minAlt) {
      this.position.y = minAlt + 1;
      this.speed *= 0.98;
      this.quaternion.slerp(this.getLevelQuat(), 3 * dt);
    }
  }
  getLevelQuat() {
    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(this.quaternion);
    forward.y = 0;
    forward.normalize();
    const m = new THREE.Matrix4().lookAt(new THREE.Vector3(), forward, new THREE.Vector3(0, 1, 0));
    return new THREE.Quaternion().setFromRotationMatrix(m);
  }
  getHeading() {
    const f = new THREE.Vector3(0, 0, -1).applyQuaternion(this.quaternion);
    let hdg = Math.atan2(f.x, -f.z) * 180 / Math.PI;
    if (hdg < 0) hdg += 360;
    return hdg;
  }
  getPitch() {
    const f = new THREE.Vector3(0, 0, -1).applyQuaternion(this.quaternion);
    return Math.asin(Math.max(-1, Math.min(1, f.y)));
  }
  getRoll() {
    const r = new THREE.Vector3(1, 0, 0).applyQuaternion(this.quaternion);
    return Math.asin(Math.max(-1, Math.min(1, -r.y)));
  }
}

// ─── InputController ───
class InputController {
  constructor(canvas) {
    this.keys = {};
    this.pitch = 0;
    this.roll = 0;
    this.throttleDir = 0;
    this.autoLevel = false;
    this.mouseX = 0;
    this.mouseY = 0;
    this.mouseLook = new THREE.Euler(0, 0, 0, 'YXZ');
    this.isLocked = false;
    this.canvas = canvas;
    this.onAircraftSwitch = null;
    this.onMenuToggle = null;
    this.onViewToggle = null;
    this.onGodModeToggle = null;
    this.onReset = null;
    this.onAutopilotToggle = null;
    window.addEventListener('keydown', e => this.onKeyDown(e));
    window.addEventListener('keyup', e => this.onKeyUp(e));
    canvas.addEventListener('click', () => {
      if (!this.isLocked) canvas.requestPointerLock();
    });
    document.addEventListener('pointerlockchange', () => {
      this.isLocked = document.pointerLockElement === canvas;
    });
    document.addEventListener('mousemove', e => {
      if (this.isLocked) {
        this.mouseX += e.movementX * 0.002;
        this.mouseY += e.movementY * 0.002;
        this.mouseX = Math.max(-1.2, Math.min(1.2, this.mouseX));
        this.mouseY = Math.max(-0.8, Math.min(0.8, this.mouseY));
      }
    });
  }
  onKeyDown(e) {
    this.keys[e.code] = true;
    if (e.code >= 'Digit1' && e.code <= 'Digit7') {
      if (this.onAircraftSwitch) this.onAircraftSwitch(parseInt(e.code.slice(5)) - 1);
    }
    if (e.code === 'Escape') {
      if (this.isLocked) document.exitPointerLock();
      if (this.onMenuToggle) this.onMenuToggle();
    }
    if (e.code === 'KeyV' && this.onViewToggle) this.onViewToggle();
    if (e.code === 'KeyG' && this.onGodModeToggle) this.onGodModeToggle();
    if (e.code === 'KeyR' && this.onReset) this.onReset();
    if (e.code === 'KeyA' && this.onAutopilotToggle) this.onAutopilotToggle();
    if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) e.preventDefault();
  }
  onKeyUp(e) { this.keys[e.code] = false; }
  update() {
    this.pitch = 0; this.roll = 0; this.throttleDir = 0; this.autoLevel = false; this.brake = false;
    if (this.keys['ArrowUp']) this.pitch = -1;
    if (this.keys['ArrowDown']) this.pitch = 1;
    if (this.keys['ArrowLeft']) this.roll = -1;
    if (this.keys['ArrowRight']) this.roll = 1;
    if (this.keys['KeyW'] || this.keys['ShiftLeft'] || this.keys['ShiftRight']) this.throttleDir = 1;
    if (this.keys['KeyS'] || this.keys['ControlLeft'] || this.keys['ControlRight']) this.throttleDir = -1;
    if (this.keys['Space']) this.brake = true;
    // Decay mouse look
    this.mouseX *= 0.96;
    this.mouseY *= 0.96;
    this.mouseLook.set(-this.mouseY, -this.mouseX, 0);
  }
}

// ─── HUDManager ───
class HUDManager {
  constructor() {
    this.speedEl = document.getElementById('speed-val');
    this.altEl = document.getElementById('alt-val');
    this.hdgEl = document.getElementById('hdg-val');
    this.throttleFill = document.getElementById('throttle-fill');
    this.horizonCanvas = document.getElementById('horizon-canvas');
    this.horizonCtx = this.horizonCanvas.getContext('2d');
    this.instCanvas = document.getElementById('instrument-canvas');
    this.instCtx = this.instCanvas.getContext('2d');
    this.aircraftSelect = document.getElementById('aircraft-select');
    this.locationSelect = document.getElementById('location-select');
    this.instructions = document.getElementById('instructions');
    this.menu = document.getElementById('menu');
    this.crashOverlay = document.getElementById('crash-overlay');
    this.godmodeIndicator = document.getElementById('godmode-indicator');
    this.autopilotIndicator = document.getElementById('autopilot-indicator');
    this.taxiHud = document.getElementById('taxi-hud');
    this.viewBtn = document.getElementById('view-btn');
    this.instructionsVisible = true;
    this.currentAircraftIndex = 1;
    this.instructions.addEventListener('click', () => this.hideInstructions());
  }
  hideInstructions() {
    if (!this.instructionsVisible) return;
    this.instructions.classList.add('hidden');
    this.instructionsVisible = false;
  }
  toggleMenu() { this.menu.classList.toggle('active'); }
  showCrash(show) {
    if (show) this.crashOverlay.classList.add('active');
    else this.crashOverlay.classList.remove('active');
  }
  showGodMode(on) {
    if (on) this.godmodeIndicator.classList.add('active');
    else this.godmodeIndicator.classList.remove('active');
  }
  showAutopilot(on) {
    if (on) this.autopilotIndicator.classList.add('active');
    else this.autopilotIndicator.classList.remove('active');
  }
  setViewMode(mode) {
    this.viewBtn.textContent = mode === 'cockpit' ? 'V: Cockpit' : 'V: Follow';
  }
  update(physics) {
    const kts = Math.round(physics.speed * 1.944);
    const alt = Math.round(physics.position.y * 3.281);
    const hdg = Math.round(physics.getHeading());
    this.speedEl.textContent = kts;
    this.altEl.textContent = alt;
    this.hdgEl.textContent = String(hdg).padStart(3, '0');
    this.throttleFill.style.height = (physics.throttle * 100) + '%';
    // Show taxi controls when on ground (not paraglider/hang glider)
    const acIdx = AIRCRAFT.indexOf(physics.aircraft);
    const showTaxi = physics.onGround && acIdx !== 3 && acIdx !== 4 && !physics.crashed;
    if (showTaxi) this.taxiHud.classList.add('active');
    else this.taxiHud.classList.remove('active');
    this.drawHorizon(physics.getPitch(), physics.getRoll());
    this.drawInstrumentPanel(physics);
  }
  // ─── Round gauge drawing ───
  drawGauge(ctx, cx, cy, r, value, minVal, maxVal, label, unit, ticks, color) {
    const startAngle = Math.PI * 0.8;
    const endAngle = Math.PI * 2.2;
    const range = endAngle - startAngle;
    // Background
    ctx.save();
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(5,10,5,0.85)';
    ctx.fill();
    ctx.strokeStyle = '#00ff8855';
    ctx.lineWidth = 2;
    ctx.stroke();
    // Outer ring
    ctx.beginPath();
    ctx.arc(cx, cy, r - 2, 0, Math.PI * 2);
    ctx.strokeStyle = '#335533';
    ctx.lineWidth = 1;
    ctx.stroke();
    // Tick marks and numbers
    ctx.fillStyle = color || '#00ff88';
    ctx.font = `${Math.max(8, r * 0.18)}px 'Courier New'`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    for (let i = 0; i <= ticks; i++) {
      const t = i / ticks;
      const angle = startAngle + t * range;
      const tickVal = minVal + t * (maxVal - minVal);
      const cos = Math.cos(angle), sin = Math.sin(angle);
      const isMajor = i % (ticks >= 10 ? 2 : 1) === 0;
      const innerR = isMajor ? r - 14 : r - 10;
      ctx.beginPath();
      ctx.moveTo(cx + cos * (r - 6), cy + sin * (r - 6));
      ctx.lineTo(cx + cos * innerR, cy + sin * innerR);
      ctx.strokeStyle = isMajor ? (color || '#00ff88') : '#00884466';
      ctx.lineWidth = isMajor ? 1.5 : 0.8;
      ctx.stroke();
      if (isMajor) {
        const numR = r - 22;
        ctx.fillStyle = '#00cc6688';
        ctx.fillText(Math.round(tickVal).toString(), cx + cos * numR, cy + sin * numR);
      }
    }
    // Needle
    const clampedVal = Math.max(minVal, Math.min(maxVal, value));
    const needleAngle = startAngle + ((clampedVal - minVal) / (maxVal - minVal)) * range;
    const needleLen = r - 12;
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(cx + Math.cos(needleAngle) * needleLen, cy + Math.sin(needleAngle) * needleLen);
    ctx.strokeStyle = '#ff4422';
    ctx.lineWidth = 2.5;
    ctx.stroke();
    // Needle center dot
    ctx.beginPath();
    ctx.arc(cx, cy, 3, 0, Math.PI * 2);
    ctx.fillStyle = '#ff4422';
    ctx.fill();
    // Label
    ctx.fillStyle = color || '#00ff88';
    ctx.font = `bold ${Math.max(9, r * 0.2)}px 'Courier New'`;
    ctx.textAlign = 'center';
    ctx.fillText(label, cx, cy + r * 0.35);
    // Value readout
    ctx.fillStyle = '#00ffaa';
    ctx.font = `bold ${Math.max(10, r * 0.25)}px 'Courier New'`;
    ctx.fillText(Math.round(value).toString() + (unit || ''), cx, cy + r * 0.55);
    ctx.restore();
  }
  drawInstrumentPanel(physics) {
    const ctx = this.instCtx;
    const W = this.instCanvas.width, H = this.instCanvas.height;
    ctx.clearRect(0, 0, W, H);
    const kts = physics.speed * 1.944;
    const alt = physics.position.y * 3.281;
    const hdg = physics.getHeading();
    const vsi = physics.speed * Math.sin(physics.getPitch()) * 196.85; // ft/min
    const throttle = physics.throttle * 100;
    const ac = physics.aircraft;
    const r = 65; // gauge radius
    const y = H / 2;
    const gap = 10;
    if (ac.hasEngine) {
      // Engine aircraft: ASI, ALT, HDG, VSI, THR
      const gauges = 5;
      const totalW = gauges * (r * 2) + (gauges - 1) * gap;
      const startX = (W - totalW) / 2 + r;
      this.drawGauge(ctx, startX, y, r, kts, 0, Math.round(ac.maxSpeed * 1.944 * 1.2), 'AIRSPEED', 'kt', 10);
      this.drawGauge(ctx, startX + (r * 2 + gap), y, r, alt, 0, 5000, 'ALT', 'ft', 10);
      this.drawGauge(ctx, startX + (r * 2 + gap) * 2, y, r, hdg, 0, 360, 'HDG', '°', 12);
      this.drawGauge(ctx, startX + (r * 2 + gap) * 3, y, r, vsi, -1000, 1000, 'VS', 'fpm', 10, '#44aaff');
      this.drawGauge(ctx, startX + (r * 2 + gap) * 4, y, r, throttle, 0, 100, 'POWER', '%', 10, '#ffaa44');
    } else {
      // Unpowered: ASI, ALT, VARIO
      const gauges = 3;
      const totalW = gauges * (r * 2) + (gauges - 1) * gap;
      const startX = (W - totalW) / 2 + r;
      this.drawGauge(ctx, startX, y, r, kts, 0, Math.round(ac.maxSpeed * 1.944 * 1.2), 'AIRSPEED', 'kt', 8);
      this.drawGauge(ctx, startX + (r * 2 + gap), y, r, alt, 0, 5000, 'ALT', 'ft', 10);
      this.drawGauge(ctx, startX + (r * 2 + gap) * 2, y, r, vsi, -1000, 1000, 'VARIO', 'fpm', 10, '#44aaff');
    }
  }
  drawHorizon(pitch, roll) {
    const ctx = this.horizonCtx;
    const w = 180, h = 180, cx = w/2, cy = h/2;
    const R = 84;
    ctx.clearRect(0, 0, w, h);
    // Bank angle marks around rim (drawn before clipping)
    ctx.save();
    ctx.translate(cx, cy);
    ctx.strokeStyle = '#00ff88cc';
    ctx.fillStyle = '#00ff88cc';
    const bankAngles = [10, 20, 30, 60, 90];
    for (const deg of bankAngles) {
      for (const sign of [-1, 1]) {
        const a = (-Math.PI/2) + sign * deg * Math.PI / 180;
        const isMajor = (deg === 30 || deg === 60 || deg === 90);
        const innerR = isMajor ? R - 10 : R - 6;
        ctx.lineWidth = isMajor ? 2 : 1;
        ctx.beginPath();
        ctx.moveTo(Math.cos(a) * innerR, Math.sin(a) * innerR);
        ctx.lineTo(Math.cos(a) * (R + 1), Math.sin(a) * (R + 1));
        ctx.stroke();
      }
    }
    // Triangle pointer at top (current roll reference)
    ctx.beginPath();
    ctx.moveTo(0, -R + 2);
    ctx.lineTo(-5, -R + 10);
    ctx.lineTo(5, -R + 10);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
    // Clipped horizon ball
    ctx.save();
    ctx.beginPath();
    ctx.arc(cx, cy, R - 2, 0, Math.PI * 2);
    ctx.clip();
    ctx.translate(cx, cy);
    ctx.rotate(-roll);
    const pitchOffset = pitch * 120;
    ctx.fillStyle = '#2244aa';
    ctx.fillRect(-90, -90, 180, 90 + pitchOffset);
    ctx.fillStyle = '#665533';
    ctx.fillRect(-90, pitchOffset, 180, 90 - pitchOffset);
    // Horizon line
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-90, pitchOffset);
    ctx.lineTo(90, pitchOffset);
    ctx.stroke();
    // Pitch marks
    ctx.strokeStyle = '#ffffffaa';
    ctx.lineWidth = 1;
    for (let d = -30; d <= 30; d += 10) {
      if (d === 0) continue;
      const y = pitchOffset - d * 3;
      const halfLen = Math.abs(d) % 20 === 0 ? 22 : 12;
      ctx.beginPath();
      ctx.moveTo(-halfLen, y);
      ctx.lineTo(halfLen, y);
      ctx.stroke();
      // Degree labels
      if (Math.abs(d) % 20 === 0) {
        ctx.fillStyle = '#ffffffaa';
        ctx.font = '9px monospace';
        ctx.textAlign = 'right';
        ctx.fillText(Math.abs(d).toString(), -halfLen - 3, y + 3);
        ctx.textAlign = 'left';
        ctx.fillText(Math.abs(d).toString(), halfLen + 3, y + 3);
      }
    }
    ctx.restore();
    // Miniature airplane symbol (fixed reference at center)
    ctx.strokeStyle = '#ffaa00';
    ctx.fillStyle = '#ffaa00';
    ctx.lineWidth = 2.5;
    // Left wing
    ctx.beginPath();
    ctx.moveTo(cx - 32, cy);
    ctx.lineTo(cx - 10, cy);
    ctx.stroke();
    // Right wing
    ctx.beginPath();
    ctx.moveTo(cx + 10, cy);
    ctx.lineTo(cx + 32, cy);
    ctx.stroke();
    // Wing tips (down ticks)
    ctx.beginPath();
    ctx.moveTo(cx - 32, cy);
    ctx.lineTo(cx - 32, cy + 6);
    ctx.moveTo(cx + 32, cy);
    ctx.lineTo(cx + 32, cy + 6);
    ctx.stroke();
    // Center dot
    ctx.beginPath();
    ctx.arc(cx, cy, 3, 0, Math.PI * 2);
    ctx.fill();
    // Tail
    ctx.beginPath();
    ctx.moveTo(cx, cy + 4);
    ctx.lineTo(cx, cy + 12);
    ctx.stroke();
    // Outer ring — bright green border
    ctx.strokeStyle = '#00ff88aa';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(cx, cy, R, 0, Math.PI * 2);
    ctx.stroke();
  }
}

// ─── PostProcessing ───
class PostProcessing {
  constructor(renderer, scene, camera) {
    this.composer = new EffectComposer(renderer);
    this.composer.addPass(new RenderPass(scene, camera));
    this.bloomPass = new UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight), 0.2, 0.4, 0.85
    );
    this.composer.addPass(this.bloomPass);
    this.fxaaPass = new ShaderPass(FXAAShader);
    this.updateSize();
    this.composer.addPass(this.fxaaPass);
    this.composer.addPass(new OutputPass());
  }
  updateSize() {
    const w = window.innerWidth, h = window.innerHeight;
    this.fxaaPass.material.uniforms['resolution'].value.set(1/w, 1/h);
    this.composer.setSize(w, h);
  }
  render() { this.composer.render(); }
}

// ─── LocationManager ───
class LocationManager {
  constructor(terrain, water, sky, vegetation, landmarks, airstrips) {
    this.terrain = terrain;
    this.water = water;
    this.sky = sky;
    this.vegetation = vegetation;
    this.landmarks = landmarks;
    this.airstrips = airstrips;
    this.currentIndex = 0;
  }
  switchTo(index, physics) {
    this.currentIndex = index;
    const loc = LOCATIONS[index];
    this.terrain.setLocation(loc);
    this.water.create(loc);
    if (this.water.water) this.sky.setSunOnWater(this.water.water);
    this.sky.configure(loc);
    this.vegetation.clearAll();
    if (this.airstrips) this.airstrips.clearAll();
    this.landmarks.build(loc, this.terrain);
    if (physics) physics.reset(loc);
  }
  getLoc() { return LOCATIONS[this.currentIndex]; }
}

// ─── SmartAutoPilot ───
class SmartAutoPilot {
  constructor() {
    this.active = false;
    this.time = 0;
    this.phase = 'cruise';
    this.phaseTimer = 0;
    this.phaseDuration = 8;
    this.targetAlt = 150;
    this.targetHeading = 0;
    this.targetBank = 0;
    this.targetPitch = 0;
    this.targetThrottle = 0.6;
    this.swoopDepth = 0;
    this.turnDir = 1;
    this.waypointAngle = 0;
  }
  toggle() {
    this.active = !this.active;
    if (this.active) {
      this.phase = 'cruise';
      this.phaseTimer = 0;
      this.phaseDuration = 5 + Math.random() * 5;
    }
    return this.active;
  }
  update(dt, physics, terrain) {
    if (!this.active) return;
    this.time += dt;
    this.phaseTimer += dt;
    const ac = physics.aircraft;
    const pos = physics.position;
    const groundH = terrain.getHeight(pos.x, pos.z);
    const waterLevel = terrain.loc.waterLevel || -100;
    const terrainH = Math.max(groundH, waterLevel);
    const agl = pos.y - terrainH; // above ground level
    // Transition phases
    if (this.phaseTimer > this.phaseDuration) {
      this.phaseTimer = 0;
      this.pickNextPhase(agl, terrainH, ac);
    }
    // Look ahead for terrain
    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(physics.quaternion);
    const lookAheadDist = physics.speed * 4;
    const aheadH = terrain.getHeight(pos.x + forward.x * lookAheadDist, pos.z + forward.z * lookAheadDist);
    const aheadTerrainH = Math.max(aheadH, waterLevel);
    // Emergency climb if terrain ahead is high
    if (aheadTerrainH > pos.y - 30) {
      this.targetPitch = -0.4;
      this.targetThrottle = 1.0;
      this.targetBank = 0;
    }
    // Minimum safe altitude
    const minSafe = terrainH + 25;
    if (pos.y < minSafe) {
      this.targetPitch = -0.3;
      this.targetThrottle = Math.max(this.targetThrottle, 0.8);
    }
    // Execute phase behavior
    switch (this.phase) {
      case 'cruise':
        this.executeCruise(dt, agl, terrainH);
        break;
      case 'swoop':
        this.executeSwoop(dt, agl, terrainH);
        break;
      case 'bank_turn':
        this.executeBankTurn(dt, agl);
        break;
      case 'climb':
        this.executeClimb(dt, agl, terrainH);
        break;
      case 'scenic_low':
        this.executeScenicLow(dt, agl, terrainH);
        break;
      case 'valley_run':
        this.executeValleyRun(dt, agl, terrainH, terrain, physics);
        break;
    }
    // Apply controls smoothly
    this.applyControls(dt, physics);
  }
  pickNextPhase(agl, terrainH, ac) {
    const phases = ac.hasEngine
      ? ['cruise', 'swoop', 'bank_turn', 'climb', 'scenic_low', 'valley_run', 'bank_turn']
      : ['cruise', 'bank_turn', 'cruise', 'bank_turn'];
    const prevPhase = this.phase;
    this.phase = phases[Math.floor(Math.random() * phases.length)];
    // Don't repeat swoop/valley immediately
    if ((this.phase === 'swoop' || this.phase === 'valley_run') && (prevPhase === 'swoop' || prevPhase === 'valley_run')) {
      this.phase = 'cruise';
    }
    this.turnDir = Math.random() > 0.5 ? 1 : -1;
    this.phaseDuration = 6 + Math.random() * 10;
    this.swoopDepth = 0;
    // Ensure enough altitude for swoop
    if (this.phase === 'swoop' && agl < 80) this.phase = 'climb';
    if (this.phase === 'valley_run' && agl < 60) this.phase = 'climb';
    if (this.phase === 'scenic_low' && agl < 40) this.phase = 'climb';
  }
  executeCruise(dt, agl, terrainH) {
    this.targetAlt = terrainH + 80 + Math.sin(this.time * 0.1) * 30;
    this.targetBank = Math.sin(this.time * 0.15) * 0.15; // gentle weave
    this.targetPitch = (this.targetAlt - (terrainH + agl)) * 0.005;
    this.targetPitch = Math.max(-0.2, Math.min(0.15, this.targetPitch));
    this.targetThrottle = 0.6;
  }
  executeSwoop(dt, agl, terrainH) {
    const t = this.phaseTimer / this.phaseDuration;
    if (t < 0.4) {
      // Dive down
      this.targetPitch = 0.3;
      this.targetThrottle = 0.3;
      this.targetBank = this.turnDir * 0.1;
    } else if (t < 0.6) {
      // Level low
      this.targetPitch = 0;
      this.targetThrottle = 0.7;
      this.targetBank = 0;
      // Enforce minimum altitude
      if (agl < 20) this.targetPitch = -0.2;
    } else {
      // Pull up
      this.targetPitch = -0.35;
      this.targetThrottle = 0.9;
      this.targetBank = this.turnDir * 0.15;
    }
  }
  executeBankTurn(dt, agl) {
    this.targetBank = this.turnDir * 0.5;
    this.targetPitch = -0.05; // Slight climb in turn
    this.targetThrottle = 0.65;
  }
  executeClimb(dt, agl, terrainH) {
    this.targetPitch = -0.25;
    this.targetThrottle = 0.9;
    this.targetBank = Math.sin(this.time * 0.2) * 0.1;
    if (agl > 200) {
      this.phase = 'cruise';
      this.phaseTimer = 0;
    }
  }
  executeScenicLow(dt, agl, terrainH) {
    this.targetAlt = terrainH + 30;
    this.targetPitch = (this.targetAlt - (terrainH + agl)) * 0.008;
    this.targetPitch = Math.max(-0.15, Math.min(0.15, this.targetPitch));
    this.targetBank = Math.sin(this.time * 0.2) * 0.25;
    this.targetThrottle = 0.55;
    if (agl < 15) this.targetPitch = -0.3;
  }
  executeValleyRun(dt, agl, terrainH, terrain, physics) {
    // Follow terrain contours at low altitude
    const pos = physics.position;
    const fwd = new THREE.Vector3(0, 0, -1).applyQuaternion(physics.quaternion);
    // Sample terrain left and right
    const right = new THREE.Vector3(1, 0, 0).applyQuaternion(physics.quaternion);
    const sampleDist = 80;
    const leftH = terrain.getHeight(pos.x - right.x * sampleDist, pos.z - right.z * sampleDist);
    const rightH = terrain.getHeight(pos.x + right.x * sampleDist, pos.z + right.z * sampleDist);
    // Steer toward lower terrain
    const heightDiff = rightH - leftH;
    this.targetBank = Math.max(-0.4, Math.min(0.4, heightDiff * 0.01));
    this.targetAlt = terrainH + 35;
    this.targetPitch = (this.targetAlt - (terrainH + agl)) * 0.01;
    this.targetPitch = Math.max(-0.2, Math.min(0.2, this.targetPitch));
    this.targetThrottle = 0.6;
    if (agl < 15) this.targetPitch = -0.3;
  }
  applyControls(dt, physics) {
    const ac = physics.aircraft;
    // Smoothly apply pitch
    const currentPitch = physics.getPitch();
    const pitchError = this.targetPitch - currentPitch;
    const pitchInput = Math.max(-1, Math.min(1, pitchError * 3));
    // Smoothly apply bank
    const currentBank = physics.getRoll();
    const bankError = this.targetBank - currentBank;
    const rollInput = Math.max(-1, Math.min(1, bankError * 3));
    // Apply rotations
    const pitchQ = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), pitchInput * ac.pitchRate * dt);
    const rollQ = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 0, -1), rollInput * ac.rollRate * dt);
    physics.quaternion.multiply(pitchQ);
    physics.quaternion.multiply(rollQ);
    // Yaw from bank
    const right = new THREE.Vector3(1, 0, 0).applyQuaternion(physics.quaternion);
    const bankAngle = Math.asin(Math.max(-1, Math.min(1, -right.y)));
    const yawRate = -bankAngle * ac.yawRate * (physics.speed / 30);
    const yawQ = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), yawRate * dt);
    physics.quaternion.premultiply(yawQ);
    // Throttle
    if (ac.hasEngine) {
      physics.throttle += (this.targetThrottle - physics.throttle) * dt * 2;
      physics.throttle = Math.max(0, Math.min(1, physics.throttle));
    }
  }
}

// ─── App ───
class App {
  constructor() {
    this.canvas = document.getElementById('main');
    this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true });
    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
    this.renderer.toneMappingExposure = 0.7;
    this.scene = new THREE.Scene();
    this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 8000);
    this.cameraHolder = new THREE.Object3D();
    this.cameraHolder.add(this.camera);
    this.scene.add(this.cameraHolder);
    // Camera system
    this.cameraMode = 'cockpit'; // 'cockpit' or 'follow'
    this.followCamPos = new THREE.Vector3();
    this.followCamTarget = new THREE.Vector3();
    this.followCamInitialized = false;
    const noise = new NoiseGenerator(42);
    this.noise = noise;
    this.terrain = new TerrainSystem(this.scene, noise);
    this.water = new WaterSystem(this.scene, noise);
    this.sky = new SkyAtmosphere(this.scene);
    this.vegetation = new VegetationSystem(this.scene, noise);
    this.landmarks = new LandmarkSystem(this.scene);
    this.airstrips = new AirstripSystem(this.scene, noise);
    this.cockpit = new CockpitRenderer(this.camera);
    this.aircraftModels = new AircraftModels(this.scene);
    this.physics = new FlightPhysics();
    this.autopilot = new SmartAutoPilot();
    this.input = new InputController(this.canvas);
    this.hud = new HUDManager();
    this.post = new PostProcessing(this.renderer, this.scene, this.camera);
    this.locMgr = new LocationManager(this.terrain, this.water, this.sky, this.vegetation, this.landmarks, this.airstrips);
    // Setup event handlers
    this.input.onAircraftSwitch = (i) => this.switchAircraft(i);
    this.input.onMenuToggle = () => this.hud.toggleMenu();
    this.input.onViewToggle = () => this.toggleCameraMode();
    this.input.onGodModeToggle = () => this.toggleGodMode();
    this.input.onReset = () => this.resetFlight();
    this.input.onAutopilotToggle = () => this.toggleAutopilot();
    this.hud.aircraftSelect.addEventListener('change', e => this.switchAircraft(parseInt(e.target.value)));
    this.hud.locationSelect.addEventListener('change', e => this.switchLocation(parseInt(e.target.value)));
    this.hud.viewBtn.addEventListener('click', () => this.toggleCameraMode());
    window.addEventListener('resize', () => this.onResize());
    // Init
    this.switchAircraft(1);
    this.locMgr.switchTo(0, this.physics);
    this.clock = new THREE.Clock();
    this.animate();
  }
  toggleCameraMode() {
    this.cameraMode = this.cameraMode === 'cockpit' ? 'follow' : 'cockpit';
    this.followCamInitialized = false;
    if (this.cameraMode === 'cockpit') {
      this.cockpit.group.visible = true;
      this.aircraftModels.hide();
    } else {
      this.cockpit.group.visible = false;
      this.aircraftModels.show(this.physics.aircraft === AIRCRAFT[0] ? 0 :
        this.physics.aircraft === AIRCRAFT[1] ? 1 :
        this.physics.aircraft === AIRCRAFT[2] ? 2 :
        this.physics.aircraft === AIRCRAFT[3] ? 3 : 4);
    }
    this.hud.setViewMode(this.cameraMode);
  }
  toggleGodMode() {
    this.physics.godMode = !this.physics.godMode;
    this.hud.showGodMode(this.physics.godMode);
  }
  resetFlight() {
    this.physics.crashed = false;
    this.physics.reset(this.locMgr.getLoc());
    this.hud.showCrash(false);
    this.followCamInitialized = false;
    if (this.autopilot.active) {
      this.autopilot.toggle();
      this.hud.showAutopilot(false);
    }
  }
  toggleAutopilot() {
    const on = this.autopilot.toggle();
    this.hud.showAutopilot(on);
    // Enable god mode when autopilot is on for smooth experience
    if (on && !this.physics.godMode) {
      this.physics.godMode = true;
      this.hud.showGodMode(true);
    }
  }
  switchAircraft(index) {
    this.physics.setAircraft(index);
    this.cockpit.build(index);
    this.hud.aircraftSelect.value = index;
    if (this.cameraMode === 'follow') {
      this.aircraftModels.show(index);
    }
  }
  switchLocation(index) {
    this.locMgr.switchTo(index, this.physics);
    this.hud.locationSelect.value = index;
    this.followCamInitialized = false;
  }
  onResize() {
    const w = window.innerWidth, h = window.innerHeight;
    this.camera.aspect = w / h;
    this.camera.updateProjectionMatrix();
    this.renderer.setSize(w, h);
    this.post.updateSize();
  }
  updateFollowCamera(dt) {
    const pos = this.physics.position;
    const quat = this.physics.quaternion;
    // Desired position: behind and above
    const behind = new THREE.Vector3(0, 0, 1).applyQuaternion(quat).multiplyScalar(20);
    const up = new THREE.Vector3(0, 7, 0);
    const desiredPos = pos.clone().add(behind).add(up);
    if (!this.followCamInitialized) {
      this.followCamPos.copy(desiredPos);
      this.followCamTarget.copy(pos);
      this.followCamInitialized = true;
    }
    // Spring-damped follow
    const smoothing = 1 - Math.pow(0.01, dt);
    this.followCamPos.lerp(desiredPos, smoothing);
    this.followCamTarget.lerp(pos, smoothing);
    // Ensure camera doesn't go below terrain
    const camGroundH = this.terrain.getHeight(this.followCamPos.x, this.followCamPos.z);
    const camWater = this.terrain.loc.waterLevel || -100;
    const camMinH = Math.max(camGroundH, camWater) + 3;
    if (this.followCamPos.y < camMinH) this.followCamPos.y = camMinH;
    this.cameraHolder.position.copy(this.followCamPos);
    this.cameraHolder.quaternion.identity();
    this.camera.rotation.set(0, 0, 0);
    // Apply mouse look as orbit around target
    const lookOffset = new THREE.Euler(-this.input.mouseY * 0.5, -this.input.mouseX * 0.5, 0, 'YXZ');
    const lookQuat = new THREE.Quaternion().setFromEuler(lookOffset);
    const lookDir = this.followCamTarget.clone().sub(this.followCamPos).normalize();
    const lookMat = new THREE.Matrix4().lookAt(new THREE.Vector3(), lookDir, new THREE.Vector3(0, 1, 0));
    const baseLookQuat = new THREE.Quaternion().setFromRotationMatrix(lookMat);
    baseLookQuat.multiply(lookQuat);
    this.cameraHolder.quaternion.copy(baseLookQuat);
  }
  animate() {
    requestAnimationFrame(() => this.animate());
    const dt = Math.min(this.clock.getDelta(), 0.05);
    // Update input
    this.input.update();
    // Autopilot or manual physics
    if (this.autopilot.active && !this.physics.crashed) {
      // Autopilot handles its own rotations, then we run physics movement only
      this.autopilot.update(dt, this.physics, this.terrain);
      // Still need to run physics for thrust/drag/movement but skip input rotations
      this.physics.updateMovementOnly(dt, this.terrain, this.airstrips);
    } else {
      this.physics.update(dt, this.input, this.terrain, this.airstrips);
    }
    // Check for crash
    if (this.physics.crashed) {
      this.hud.showCrash(true);
    }
    // Update camera based on mode
    if (this.cameraMode === 'cockpit') {
      this.cameraHolder.position.copy(this.physics.position);
      this.cameraHolder.quaternion.copy(this.physics.quaternion);
      this.camera.rotation.copy(this.input.mouseLook);
    } else {
      this.updateFollowCamera(dt);
      // Update aircraft model transform
      this.aircraftModels.updateTransform(this.physics.position, this.physics.quaternion);
      this.aircraftModels.updatePropeller(dt);
      this.aircraftModels.updateAfterburner(dt, this.physics.throttle, this.physics.aircraft);
    }
    // Update systems
    const px = this.physics.position.x, pz = this.physics.position.z;
    this.terrain.update(px, pz);
    this.water.update(dt, px, pz);
    // Vegetation and airstrips for loaded terrain chunks
    const loc = this.locMgr.getLoc();
    const pcx = Math.round(px / CHUNK_SIZE), pcz = Math.round(pz / CHUNK_SIZE);
    let vegGenerated = 0;
    let stripGenerated = 0;
    for (let dx = -GRID_RADIUS; dx <= GRID_RADIUS; dx++) {
      for (let dz = -GRID_RADIUS; dz <= GRID_RADIUS; dz++) {
        const cx = pcx + dx, cz = pcz + dz;
        const key = cx + ',' + cz;
        if (this.terrain.chunks.has(key)) {
          if (!this.vegetation.chunkTrees.has(key) && vegGenerated < 1) {
            this.vegetation.generateForChunk(cx, cz, loc, this.terrain);
            vegGenerated++;
          }
          if (stripGenerated < 1) {
            this.airstrips.generateForChunk(cx, cz, this.terrain);
            stripGenerated++;
          }
        }
      }
    }
    this.vegetation.pruneChunks(pcx, pcz);
    this.airstrips.pruneChunks(pcx, pcz);
    // Update cockpit instruments
    if (this.cameraMode === 'cockpit') {
      this.cockpit.updateInstruments(this.physics);
    }
    // HUD
    this.hud.update(this.physics);
    // Render
    this.post.render();
  }
}

new App();
</script>
</body>
</html>
